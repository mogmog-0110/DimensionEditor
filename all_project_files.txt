フォルダー パスの一覧:  ボリューム Windows
ボリューム シリアル番号は CEC5-6F65 です
C:.
│  .gitignore
│  .gitmodules
│  all_project_files.txt
│  DimensionEditor.sln
│  
├─DimensionEditor
│  │  .editorconfig
│  │  DimensionEditor.vcxproj
│  │  DimensionEditor.vcxproj.filters
│  │  DimensionEditor.vcxproj.user
│  │  ImGuiHelpers.hpp
│  │  Main.cpp
│  │  SchemaManager.hpp
│  │  stdafx.cpp
│  │  stdafx.h
│  │  
│  ├─App
│  │  │  DimensionEditor(debug).exe
│  │  │  DimensionEditor.exe
│  │  │  editor_config.json
│  │  │  icon.ico
│  │  │  imgui.ini
│  │  │  Resource.rc
│  │  │  
│  │  ├─assets
│  │  │  └─font
│  │  ├─AS_DEBUG
│  │  │      stats.txt
│  │  │      
│  │  ├─dll
│  │  │  └─soundtouch
│  │  │          COPYING.TXT
│  │  │          SoundTouch_x64.dll
│  │  │          
│  │  ├─engine
│  │  │  ├─font
│  │  │  │  ├─fontawesome
│  │  │  │  │      fontawesome-brands.otf.zstdcmp
│  │  │  │  │      fontawesome-solid.otf.zstdcmp
│  │  │  │  │      LICENSE.txt
│  │  │  │  │      
│  │  │  │  ├─materialdesignicons
│  │  │  │  │      license.md
│  │  │  │  │      materialdesignicons-webfont.ttf.zstdcmp
│  │  │  │  │      
│  │  │  │  ├─min
│  │  │  │  │      LICENSE
│  │  │  │  │      siv3d-min.woff
│  │  │  │  │      
│  │  │  │  ├─mplus
│  │  │  │  │      LICENSE_E
│  │  │  │  │      mplus-1p-black.ttf.zstdcmp
│  │  │  │  │      mplus-1p-bold.ttf.zstdcmp
│  │  │  │  │      mplus-1p-heavy.ttf.zstdcmp
│  │  │  │  │      mplus-1p-light.ttf.zstdcmp
│  │  │  │  │      mplus-1p-medium.ttf.zstdcmp
│  │  │  │  │      mplus-1p-regular.ttf.zstdcmp
│  │  │  │  │      mplus-1p-thin.ttf.zstdcmp
│  │  │  │  │      
│  │  │  │  ├─noto-cjk
│  │  │  │  │      LICENSE
│  │  │  │  │      NotoSansCJK-Regular.ttc.zstdcmp
│  │  │  │  │      NotoSansJP-Regular.otf.zstdcmp
│  │  │  │  │      
│  │  │  │  └─noto-emoji
│  │  │  │          LICENSE
│  │  │  │          NotoColorEmoji.ttf.zstdcmp
│  │  │  │          NotoEmoji-Regular.ttf.zstdcmp
│  │  │  │          
│  │  │  ├─shader
│  │  │  │  ├─d3d11
│  │  │  │  │      apply_srgb_curve.ps
│  │  │  │  │      bitmapfont.ps
│  │  │  │  │      copy.ps
│  │  │  │  │      forward3d.ps
│  │  │  │  │      forward3d.vs
│  │  │  │  │      fullscreen_triangle.ps
│  │  │  │  │      fullscreen_triangle.vs
│  │  │  │  │      gaussian_blur_13.ps
│  │  │  │  │      gaussian_blur_5.ps
│  │  │  │  │      gaussian_blur_9.ps
│  │  │  │  │      line3d.ps
│  │  │  │  │      line3d.vs
│  │  │  │  │      msdffont.ps
│  │  │  │  │      msdffont_outline.ps
│  │  │  │  │      msdffont_outlineshadow.ps
│  │  │  │  │      msdffont_shadow.ps
│  │  │  │  │      msdfprint.ps
│  │  │  │  │      quad_warp.ps
│  │  │  │  │      quad_warp.vs
│  │  │  │  │      round_dot.ps
│  │  │  │  │      sdffont.ps
│  │  │  │  │      sdffont_outline.ps
│  │  │  │  │      sdffont_outlineshadow.ps
│  │  │  │  │      sdffont_shadow.ps
│  │  │  │  │      shape.ps
│  │  │  │  │      sky.ps
│  │  │  │  │      sprite.vs
│  │  │  │  │      square_dot.ps
│  │  │  │  │      texture.ps
│  │  │  │  │      
│  │  │  │  └─glsl
│  │  │  │          apply_srgb_curve.frag
│  │  │  │          bitmapfont.frag
│  │  │  │          copy.frag
│  │  │  │          forward3d.frag
│  │  │  │          forward3d.vert
│  │  │  │          fullscreen_triangle.frag
│  │  │  │          fullscreen_triangle.vert
│  │  │  │          gaussian_blur_13.frag
│  │  │  │          gaussian_blur_5.frag
│  │  │  │          gaussian_blur_9.frag
│  │  │  │          line3d.frag
│  │  │  │          line3d.vert
│  │  │  │          msdffont.frag
│  │  │  │          msdffont_outline.frag
│  │  │  │          msdffont_outlineshadow.frag
│  │  │  │          msdffont_shadow.frag
│  │  │  │          msdfprint.frag
│  │  │  │          quad_warp.frag
│  │  │  │          quad_warp.vert
│  │  │  │          round_dot.frag
│  │  │  │          sdffont.frag
│  │  │  │          sdffont_outline.frag
│  │  │  │          sdffont_outlineshadow.frag
│  │  │  │          sdffont_shadow.frag
│  │  │  │          shape.frag
│  │  │  │          sky.frag
│  │  │  │          sprite.vert
│  │  │  │          square_dot.frag
│  │  │  │          texture.frag
│  │  │  │          
│  │  │  ├─soundfont
│  │  │  │      GMGSx.sf2.txt
│  │  │  │      GMGSx.sf2.zstdcmp
│  │  │  │      
│  │  │  └─texture
│  │  │      └─box-shadow
│  │  │              128.png
│  │  │              16.png
│  │  │              256.png
│  │  │              32.png
│  │  │              64.png
│  │  │              8.png
│  │  │              
│  │  └─example
│  │      │  bay.jpg
│  │      │  LICENSE.txt
│  │      │  particle.png
│  │      │  shot.mp3
│  │      │  siv3d-kun.png
│  │      │  test.mp3
│  │      │  windmill.png
│  │      │  
│  │      ├─csv
│  │      │      config.csv
│  │      │      
│  │      ├─font
│  │      │  ├─DotGothic16
│  │      │  │      DotGothic16-Regular.ttf
│  │      │  │      OFL.txt
│  │      │  │      README-JP.md
│  │      │  │      README.md
│  │      │  │      
│  │      │  └─RocknRoll
│  │      │          OFL.txt
│  │      │          README-JP.md
│  │      │          README.md
│  │      │          RocknRollOne-Regular.ttf
│  │      │          
│  │      ├─geojson
│  │      │      countries.geojson
│  │      │      
│  │      ├─gif
│  │      │      test.gif
│  │      │      
│  │      ├─ini
│  │      │      config.ini
│  │      │      
│  │      ├─json
│  │      │      config.json
│  │      │      empty.json
│  │      │      invalid-blank.json
│  │      │      invalid-syntax.json
│  │      │      test.json
│  │      │      
│  │      ├─midi
│  │      │      test.mid
│  │      │      test.txt
│  │      │      
│  │      ├─obj
│  │      │      bark.jpg
│  │      │      blacksmith.mtl
│  │      │      blacksmith.obj
│  │      │      credit.txt
│  │      │      crystal1.mtl
│  │      │      crystal1.obj
│  │      │      crystal2.mtl
│  │      │      crystal2.obj
│  │      │      crystal3.mtl
│  │      │      crystal3.obj
│  │      │      leaves.png
│  │      │      mill.mtl
│  │      │      mill.obj
│  │      │      pine.mtl
│  │      │      pine.obj
│  │      │      pine_leaves_red.png
│  │      │      siv3d-kun-eye.png
│  │      │      siv3d-kun.mtl
│  │      │      siv3d-kun.obj
│  │      │      siv3d-kun.png
│  │      │      tree.mtl
│  │      │      tree.obj
│  │      │      
│  │      ├─objdetect
│  │      │  └─haarcascade
│  │      │          eye.xml
│  │      │          face_anime.xml
│  │      │          frontal_catface.xml
│  │      │          frontal_face_alt2.xml
│  │      │          
│  │      ├─script
│  │      │      breakout.as
│  │      │      hello.as
│  │      │      paint.as
│  │      │      piano.as
│  │      │      test.as
│  │      │      
│  │      ├─shader
│  │      │  ├─glsl
│  │      │  │      default2d.vert
│  │      │  │      default2d_shape.frag
│  │      │  │      default2d_texture.frag
│  │      │  │      default3d_forward.frag
│  │      │  │      default3d_forward.vert
│  │      │  │      default3d_forward_shadow_depth.frag
│  │      │  │      default3d_forward_shadow_shading.frag
│  │      │  │      extract_bright_linear.frag
│  │      │  │      forward_fog.frag
│  │      │  │      forward_triplanar.frag
│  │      │  │      game_of_life.frag
│  │      │  │      grayscale.frag
│  │      │  │      homography.frag
│  │      │  │      homography.vert
│  │      │  │      multi_texture_blend.frag
│  │      │  │      multi_texture_mask.frag
│  │      │  │      poisson_disk.frag
│  │      │  │      posterize.frag
│  │      │  │      rgb_shift.frag
│  │      │  │      rgb_to_bgr.frag
│  │      │  │      soft_shape.vert
│  │      │  │      swirl.frag
│  │      │  │      terrain_forward.frag
│  │      │  │      terrain_forward.vert
│  │      │  │      terrain_normal.frag
│  │      │  │      
│  │      │  └─hlsl
│  │      │          default2d.hlsl
│  │      │          default3d_forward.hlsl
│  │      │          default3d_forward_shadow.hlsl
│  │      │          extract_bright_linear.hlsl
│  │      │          forward_fog.hlsl
│  │      │          forward_triplanar.hlsl
│  │      │          game_of_life.hlsl
│  │      │          grayscale.hlsl
│  │      │          homography.hlsl
│  │      │          multi_texture_blend.hlsl
│  │      │          multi_texture_mask.hlsl
│  │      │          poisson_disk.hlsl
│  │      │          posterize.hlsl
│  │      │          rgb_shift.hlsl
│  │      │          rgb_to_bgr.hlsl
│  │      │          soft_shape.hlsl
│  │      │          swirl.hlsl
│  │      │          terrain_forward.hlsl
│  │      │          terrain_normal.hlsl
│  │      │          
│  │      ├─spritesheet
│  │      │      siv3d-kun-16.png
│  │      │      siv3d-kun-16.txt
│  │      │      
│  │      ├─svg
│  │      │      cat.svg
│  │      │      README.txt
│  │      │      turtle.svg
│  │      │      
│  │      ├─texture
│  │      │      credit.txt
│  │      │      earth.jpg
│  │      │      grass.jpg
│  │      │      ground.jpg
│  │      │      rock.jpg
│  │      │      uv.png
│  │      │      wood.jpg
│  │      │      
│  │      ├─toml
│  │      │      config.toml
│  │      │      test.toml
│  │      │      
│  │      ├─txt
│  │      │      en.txt
│  │      │      jp.txt
│  │      │      kr.txt
│  │      │      sc.txt
│  │      │      
│  │      ├─video
│  │      │      river.mp4
│  │      │      river.txt
│  │      │      
│  │      ├─xml
│  │      │      config.xml
│  │      │      test.xml
│  │      │      
│  │      └─zip
│  │              zip_test.zip
│  │              
│  ├─Controller
│  │      EditorController.cpp
│  │      EditorController.hpp
│  │      EditorDrafts.hpp
│  │      
│  ├─imgui-s3d-wrapper
│  │  │  README.md
│  │  │  
│  │  └─imgui
│  │          DearImGuiAddon.cpp
│  │          DearImGuiAddon.hpp
│  │          imconfig.h
│  │          imgui.cpp
│  │          imgui.h
│  │          imgui_demo.cpp
│  │          imgui_draw.cpp
│  │          imgui_impl_s3d.cpp
│  │          imgui_impl_s3d.h
│  │          imgui_internal.h
│  │          imgui_tables.cpp
│  │          imgui_widgets.cpp
│  │          imstb_rectpack.h
│  │          imstb_textedit.h
│  │          imstb_truetype.h
│  │          
│  ├─Model
│  │      DimensionModel.cpp
│  │      DimensionModel.hpp
│  │      
│  └─View
│      │  EditorView.cpp
│      │  EditorView.hpp
│      │  
│      └─Inspector
│              GenericDrawer.cpp
│              GenericDrawer.hpp
│              IInspectorDrawer.hpp
│              InspectorDrawerFactory.hpp
│              InspectorDrawerUtils.cpp
│              InspectorDrawerUtils.hpp
│              RoomConnectionsDrawer.cpp
│              RoomConnectionsDrawer.hpp
│              SchemaDrivenDrawer.cpp
│              SchemaDrivenDrawer.hpp
│              
└─Intermediate
    └─DimensionEditor
        ├─Debug
        │  │  DimensionEditor(debug).exe
        │  │  DimensionEditor(debug).exp
        │  │  DimensionEditor(debug).lib
        │  │  DimensionEditor(debug).pdb
        │  │  
        │  └─Intermediate
        │      │  DearImGuiAddon.obj
        │      │  DimensionEditor(debug).Build.CppClean.log
        │      │  DimensionEditor(debug).exe.recipe
        │      │  DimensionEditor(debug).ilk
        │      │  DimensionEditor(debug).pch
        │      │  DimensionEditor.log
        │      │  DimensionModel.obj
        │      │  EditorController.obj
        │      │  EditorDataManager.obj
        │      │  EditorView.obj
        │      │  GenericDrawer.obj
        │      │  imgui.obj
        │      │  imgui_demo.obj
        │      │  imgui_draw.obj
        │      │  imgui_impl_s3d.obj
        │      │  imgui_tables.obj
        │      │  imgui_widgets.obj
        │      │  InspectorDrawerUtils.obj
        │      │  Main.obj
        │      │  Resource.res
        │      │  RoomConnectionsDrawer.obj
        │      │  SchemaDrivenDrawer.obj
        │      │  stdafx.obj
        │      │  vc143.idb
        │      │  vc143.pdb
        │      │  
        │      ├─DimensionEditor.tlog
        │      │      CL.command.1.tlog
        │      │      Cl.items.tlog
        │      │      CL.read.1.tlog
        │      │      CL.write.1.tlog
        │      │      DimensionEditor.lastbuildstate
        │      │      link.command.1.tlog
        │      │      link.read.1.tlog
        │      │      link.secondary.1.tlog
        │      │      link.write.1.tlog
        │      │      rc.command.1.tlog
        │      │      rc.read.1.tlog
        │      │      rc.write.1.tlog
        │      │      
        │      ├─DimensionEditor_MD.tlog
        │      └─microsoft
        │          └─STL
        └─Release
            │  DimensionEditor.exe
            │  DimensionEditor.exp
            │  DimensionEditor.lib
            │  DimensionEditor.pdb
            │  
            └─Intermediate
                │  DearImGuiAddon.obj
                │  DimensionEditor.exe.recipe
                │  DimensionEditor.iobj
                │  DimensionEditor.ipdb
                │  DimensionEditor.log
                │  DimensionEditor.pch
                │  DimensionModel.obj
                │  EditorController.obj
                │  EditorView.obj
                │  GenericDrawer.obj
                │  imgui.obj
                │  imgui_demo.obj
                │  imgui_draw.obj
                │  imgui_impl_s3d.obj
                │  imgui_tables.obj
                │  imgui_widgets.obj
                │  InspectorDrawerUtils.obj
                │  Main.obj
                │  Resource.res
                │  RoomConnectionsDrawer.obj
                │  SchemaDrivenDrawer.obj
                │  stdafx.obj
                │  vc143.pdb
                │  
                ├─DimensionEditor.tlog
                │      CL.command.1.tlog
                │      Cl.items.tlog
                │      CL.read.1.tlog
                │      CL.write.1.tlog
                │      DimensionEditor.lastbuildstate
                │      link.command.1.tlog
                │      link.read.1.tlog
                │      link.secondary.1.tlog
                │      link.write.1.tlog
                │      rc.command.1.tlog
                │      rc.read.1.tlog
                │      rc.write.1.tlog
                │      
                ├─DimensionEditor_MD.tlog
                └─microsoft
                    └─STL

--- FILE CONTENTS ---


--- FILE: C:\Users\KAWAMURA Yuya\source\repos\DimensionEditor\DimensionEditor\Controller\EditorController.cpp ---


#include "EditorController.hpp"
#include "../Model/DimensionModel.hpp"

namespace
{
	enum ActionTypeIndex {
		ActionType_ShowText = 0,
		ActionType_GiveItem,
		ActionType_SetFlag,
		ActionType_Conditional,
		ActionType_Sequence,
		ActionType_MultiStep,
		ActionType_ChangeDimension
	};
}

EditorController::EditorController(DimensionModel& model)
	: m_model{ model }
{
}

void EditorController::update()
{
	// 今後、キーボードショートカットなどの処理をここに追加
}

void EditorController::openDimension()
{
	const auto result = Dialog::SelectFolder(U"App/data");
	if (result)
	{
		m_model.Load(result.value());
		m_selectedPath.clear(); // 選択をリセット
	}
}

void EditorController::createNewDimension(const String& name, const FilePath& baseDir)
{
	// Viewから受け取ったパスと名前をModelに渡す
	m_model.CreateNew(baseDir, name);
	m_selectedPath.clear();
}

void EditorController::saveSelectedJson()
{
	m_model.saveJsonForPath(m_selectedPath, m_selectedJsonData);
}

void EditorController::addNewHotspot(const HotspotDraftState& hotspotState)
{
	// UIの状態からJSONデータを組み立てる
	JSON newHotspotJson = buildJsonFromState(hotspotState);

	// Modelにデータの永続化（ファイル保存）を依頼
	m_model.addHotspot(m_selectedPath, newHotspotJson);

	// Controllerが持つ現在のJSONデータも更新し、UIに即時反映させる
	m_selectedJsonData[U"hotspots"].push_back(newHotspotJson);
}

void EditorController::updateRoomData(const String& roomName, const JSON& newRoomData)
{
	if (m_selectedJsonData.hasElement(U"rooms"))
	{
		m_selectedJsonData[U"rooms"][roomName] = newRoomData;
	}
}

void EditorController::setSelectedPath(const FilePath& path)
{
	m_selectedPath = path;

	// もしパスが空でなく、JSONファイルなら、中身を読み込んで保持する
	if ((not m_selectedPath.isEmpty()) && (FileSystem::Extension(m_selectedPath) == U"json"))
	{
		m_selectedJsonData = JSON::Load(m_selectedPath);
	}
	else
	{
		m_selectedJsonData.clear(); // それ以外の場合はクリア
	}
}

JSON EditorController::buildActionJson(const ActionDraft& draft)
{
	JSON actionObj;

	// アクションの種類に応じて分岐
	switch (draft.typeIndex) {
	case ActionType_ShowText: // テキストを表示
		actionObj[U"type"] = U"ShowText";
		actionObj[U"file"] = Unicode::FromUTF8(draft.fileBuffer);
		break;
	case ActionType_GiveItem: // アイテムを入手
		actionObj[U"type"] = U"GiveItem";
		actionObj[U"item"] = Unicode::FromUTF8(draft.itemBuffer);
		break;
	case ActionType_SetFlag: // フラグを操作
		actionObj[U"type"] = U"SetFlag";
		actionObj[U"flag"] = Unicode::FromUTF8(draft.flagBuffer);
		actionObj[U"value"] = draft.flagValue;
		break;
	case ActionType_Conditional: // 条件分岐
	{
		actionObj[U"type"] = U"Conditional";
		JSON conditionObj;
		if (draft.conditionTypeIndex == 0) // HasItem
		{
			conditionObj[U"type"] = U"HasItem";
			conditionObj[U"item"] = Unicode::FromUTF8(draft.conditionItemBuffer);
		}
		else // IsFlagOn
		{
			conditionObj[U"type"] = U"IsFlagOn";
			conditionObj[U"flag"] = Unicode::FromUTF8(draft.conditionFlagBuffer);
		}
		actionObj[U"condition"] = conditionObj;

		if (draft.successAction) {
			actionObj[U"success"] = buildActionJson(*draft.successAction);
		}
		if (draft.failureAction) {
			actionObj[U"failure"] = buildActionJson(*draft.failureAction);
		}
		break;
	}
	case ActionType_Sequence: // 連続実行
	{
		actionObj[U"type"] = U"Sequence";
		Array<JSON> actionsArray;
		// unique_ptrのリストを反復処理し、中身を再帰的に処理
		for (const auto& subDraftPtr : draft.actionList)
		{
			if (subDraftPtr)
			{
				actionsArray.push_back(buildActionJson(*subDraftPtr));
			}
		}
		actionObj[U"actions"] = actionsArray;
		break;
	}
	case ActionType_MultiStep: // ステップ実行
	{
		actionObj[U"type"] = U"MultiStep";
		actionObj[U"id"] = Unicode::FromUTF8(draft.idBuffer);
		Array<JSON> stepsArray;
		for (const auto& subDraftPtr : draft.actionList)
		{
			if (subDraftPtr)
			{
				stepsArray.push_back(buildActionJson(*subDraftPtr));
			}
		}
		actionObj[U"steps"] = stepsArray;

		if (draft.finalAction)
		{
			actionObj[U"final_action"] = buildActionJson(*draft.finalAction);
		}
		break;
	}
	case ActionType_ChangeDimension:
		actionObj[U"type"] = U"ChangeDimension";
		actionObj[U"target"] = Unicode::FromUTF8(draft.targetDimensionBuffer);
		break;
	}
	return actionObj;
}

JSON EditorController::buildJsonFromState(const HotspotDraftState& state)
{
	JSON hotspotObj;
	hotspotObj[U"grid_pos"] = Unicode::FromUTF8(state.gridPosBuffer);
	hotspotObj[U"action"] = buildActionJson(state.rootAction);
	return hotspotObj;
}

void EditorController::addNewInteractable(const String& roomName, const InteractableDraftState& draft)
{
	if (not m_selectedJsonData.hasElement(U"rooms")) return;

	JSON newInteractable;
	newInteractable[U"name"] = Unicode::FromUTF8(draft.nameBuffer);
	newInteractable[U"default_state"][U"asset"] = Unicode::FromUTF8(draft.defaultStateDraft.assetBuffer);
	newInteractable[U"default_state"][U"grid_pos"] = Unicode::FromUTF8(draft.defaultStateDraft.gridPosBuffer);
	newInteractable[U"states"] = Array<JSON>();
	newInteractable[U"hotspot"] = buildJsonFromState(draft.hotspotDraft);

	if (not m_selectedJsonData[U"rooms"][roomName].hasElement(U"interactables"))
	{
		m_selectedJsonData[U"rooms"][roomName][U"interactables"] = Array<JSON>();
	}

	m_selectedJsonData[U"rooms"][roomName][U"interactables"].push_back(newInteractable);
}

void EditorController::addNewRoom(const String& roomName)
{
	m_model.AddNewRoom(roomName);
}

void EditorController::updateInteractable(const String& roomName, int interactableIndex, const InteractableDraftState& draft)
{
	if (not m_selectedJsonData.hasElement(U"rooms")) return;

	auto target = m_selectedJsonData[U"rooms"][roomName][U"interactables"][interactableIndex];
	target[U"name"] = Unicode::FromUTF8(draft.nameBuffer);
	target[U"default_state"][U"asset"] = Unicode::FromUTF8(draft.defaultStateDraft.assetBuffer);
	target[U"default_state"][U"grid_pos"] = Unicode::FromUTF8(draft.defaultStateDraft.gridPosBuffer);
	target[U"hotspot"] = buildJsonFromState(draft.hotspotDraft);
}

void EditorController::addNewFocusable(const String& roomName, const ForcusableDraftState& draft)
{
	if (not m_selectedJsonData.hasElement(U"rooms")) return;

	JSON newForcusable;
	newForcusable[U"name"] = Unicode::FromUTF8(draft.nameBuffer);
	newForcusable[U"default_state"][U"asset"] = Unicode::FromUTF8(draft.defaultStateDraft.assetBuffer);
	newForcusable[U"hotspot"][U"grid_pos"] = Unicode::FromUTF8(draft.hotspotGridPosBuffer);
	newForcusable[U"states"] = Array<JSON>();

	// forcusables 配列がなければ作成
	if (not m_selectedJsonData[U"rooms"][roomName].hasElement(U"forcusables"))
	{
		m_selectedJsonData[U"rooms"][roomName][U"forcusables"] = Array<JSON>();
	}

	m_selectedJsonData[U"rooms"][roomName][U"forcusables"].push_back(newForcusable);

	// またはファイルテンプレートを別途作成する処理を呼び出す
}

void EditorController::updateFocusable(const String& roomName, int focusableIndex, const ForcusableDraftState& draft)
{
	if (not m_selectedJsonData.hasElement(U"rooms")) return;

	auto target = m_selectedJsonData[U"rooms"][roomName][U"forcusables"][focusableIndex];
	target[U"name"] = Unicode::FromUTF8(draft.nameBuffer);
	target[U"default_state"][U"asset"] = Unicode::FromUTF8(draft.defaultStateDraft.assetBuffer);
	target[U"hotspot"][U"grid_pos"] = Unicode::FromUTF8(draft.hotspotGridPosBuffer);
}

--- FILE: C:\Users\KAWAMURA Yuya\source\repos\DimensionEditor\DimensionEditor\Controller\EditorController.hpp ---


#pragma once
#include "EditorDrafts.hpp"


class DimensionModel;
class EditorView;

class EditorController
{
public:
	explicit EditorController(DimensionModel& model);
	void update();

	// Viewからの通知を受け取る関数
	void openDimension();
	void createNewDimension(const String& name, const FilePath& baseDir);

	void setSelectedPath(const FilePath& path);

	const FilePath& getSelectedPath() const { return m_selectedPath; }

	JSON& getSelectedJsonData() { return m_selectedJsonData; }

	void saveSelectedJson();

	void addNewHotspot(const HotspotDraftState& hotspotState);

	void updateRoomData(const String& roomName, const JSON& newRoomData);


	void addNewInteractable(const String& roomName, const InteractableDraftState& draft);

	void addNewRoom(const String& roomName);

	void updateInteractable(const String& roomName, int interactableIndex, const InteractableDraftState& draft);


	void addNewFocusable(const String& roomName, const ForcusableDraftState& draft);

	void updateFocusable(const String& roomName, int focusableIndex, const ForcusableDraftState& draft);

	DimensionModel& getModel() { return m_model; }
	const DimensionModel& getModel() const { return m_model; }

private:
	JSON buildJsonFromState(const HotspotDraftState& state);
	JSON buildActionJson(const ActionDraft& draft);

	DimensionModel& m_model;
	FilePath m_selectedPath;
	JSON m_selectedJsonData;
};

--- FILE: C:\Users\KAWAMURA Yuya\source\repos\DimensionEditor\DimensionEditor\Controller\EditorDrafts.hpp ---


#pragma once
#include <Siv3D.hpp>

// ViewとControllerの両方で使われるデータ構造の定義

struct ActionDraft
{
	int typeIndex = 0;
	std::string fileBuffer;
	std::string itemBuffer;
	std::string flagBuffer;
	std::string scopeBuffer = "Dimension";
	bool flagValue = true;
	int conditionTypeIndex = 0;
	std::string conditionItemBuffer;
	std::string conditionFlagBuffer;
	std::unique_ptr<ActionDraft> successAction;
	std::unique_ptr<ActionDraft> failureAction;
	std::unique_ptr<ActionDraft> finalAction;
	std::vector<std::unique_ptr<ActionDraft>> actionList;
	std::string idBuffer;
	std::string targetDimensionBuffer;

	// コピー禁止、ムーブ許可
	ActionDraft() = default;
	~ActionDraft() = default;
	ActionDraft(ActionDraft&&) noexcept = default;
	ActionDraft& operator=(ActionDraft&&) noexcept = default;
	ActionDraft(const ActionDraft&) = delete;
	ActionDraft& operator=(const ActionDraft&) = delete;
};

struct HotspotDraftState
{
	std::string gridPosBuffer = "A1-A1";
	ActionDraft rootAction;
};

struct InteractableDraftState
{
	std::string nameBuffer;
	struct DefaultStateDraft {
		std::string assetBuffer;
		std::string gridPosBuffer;
	};
	DefaultStateDraft defaultStateDraft;
	HotspotDraftState hotspotDraft;
};

struct ForcusableDraftState
{
	std::string nameBuffer;
	std::string hotspotGridPosBuffer;

	struct DefaultStateDraft {
		std::string assetBuffer;
	};
	DefaultStateDraft defaultStateDraft;
};

--- FILE: C:\Users\KAWAMURA Yuya\source\repos\DimensionEditor\DimensionEditor\Model\DimensionModel.cpp ---


#include "DimensionModel.hpp"
#include "../SchemaManager.hpp"

namespace
{
	String GetFolderNameFromPath(FilePath path)
	{
		if (path.ends_with(U'/') || path.ends_with(U'\\'))
		{
			path.pop_back();
		}

		const size_t lastSlashPos = path.lastIndexOf(U'/');

		if (lastSlashPos != String::npos)
		{
			return path.substr(lastSlashPos + 1);
		}

		return path;
	}
}

JSON CreateTemplateFromSchema(const Schema& schema)
{
	JSON newJson;
	for (const auto& propPair : schema)
	{
		const auto& key = propPair.first;
		const auto& prop = propPair.second;

		switch (prop.type)
		{
		case JSONValueType::String:
			newJson[key] = U"";
			break;
		case JSONValueType::Number:
			newJson[key] = 0;
			break;
		case JSONValueType::Bool:
			newJson[key] = false;
			break;
		case JSONValueType::Array:
			newJson[key] = Array<JSON>();
			break;
		case JSONValueType::Object:
			// 子スキーマが定義されていれば、再帰的にテンプレートを生成
			if (prop.childSchema)
			{
				newJson[key] = CreateTemplateFromSchema(*prop.childSchema);
			}
			else
			{
				newJson[key] = JSON();
			}
			break;
		default:
			newJson[key] = JSON(); // Null
			break;
		}
	}
	return newJson;
}


JSON GetFocusableTemplate(const String& objectType)
{
	// objectTypeに一致するスキーマを取得
	if (auto schema = GetSchema(objectType))
	{
		// 取得したスキーマからテンプレートを自動生成
		return CreateTemplateFromSchema(schema.value());
	}

	// 不明な種類の場合は空のオブジェクトを返す
	Logger << U"⚠️ Warning: Schema not found for type '{}'. Creating an empty object."_fmt(objectType);
	return JSON();
}


DimensionModel::DimensionModel()
{
}

void DimensionModel::CreateNew(const FilePath& baseDir, const String& dimensionName)
{
	m_currentDimensionPath = FileSystem::PathAppend(baseDir, dimensionName);
	if (FileSystem::Exists(m_currentDimensionPath))
	{
		// 既に存在する場合は何もしない
		Logger << U"Dimension '{}' already exists."_fmt(dimensionName);
		return;
	}

	// デフォルトの部屋フォルダをすべて作成
	const Array<String> defaultRooms = {
		U"North", U"East", U"South", U"West", U"Floor", U"Ceiling", U"Multiverse"
	};

	for (const auto& roomName : defaultRooms)
	{
		FileSystem::CreateDirectories(FileSystem::PathAppend(m_currentDimensionPath, roomName));
	}

	// room_connections.json のテンプレートを生成
	JSON connectionsJson;

	// 各部屋の基本設定
	const JSON emptyLayout = JSON{
		{ U"interactable", JSON() }
	};

	// 主要な4部屋（東西南北）
	connectionsJson[U"rooms"][U"North"] = JSON{
		{ U"background", U"BG_NORTH" },
		{ U"interactables", Array<JSON>() }, 
		{ U"forcusables", Array<JSON>() },
		{ U"layout", emptyLayout }
	};
	connectionsJson[U"rooms"][U"East"] = JSON{
		{ U"background", U"BG_EAST" },
		{ U"interactables", Array<JSON>() },
		{ U"forcusables", Array<JSON>() },
		{ U"layout", emptyLayout }
	};
	connectionsJson[U"rooms"][U"South"] = JSON{
		{ U"background", U"BG_SOUTH" },
		{ U"interactables", Array<JSON>() },
		{ U"forcusables", Array<JSON>() },
		{ U"layout", emptyLayout }
	};
	connectionsJson[U"rooms"][U"West"] = JSON{
		{ U"background", U"BG_WEST" },
		{ U"interactables", Array<JSON>() },
		{ U"forcusables", Array<JSON>() },
		{ U"layout", emptyLayout }
	};

	// その他の部屋
	connectionsJson[U"rooms"][U"Ceiling"] = JSON{
		{ U"background", U"BG_CEILING" },
		{ U"interactables", Array<JSON>() },
		{ U"forcusables", Array<JSON>() },
		{ U"layout", emptyLayout }
	};
	connectionsJson[U"rooms"][U"Floor"] = JSON{
		{ U"background", U"BG_FLOOR" },
		{ U"interactables", Array<JSON>() },
		{ U"forcusables", Array<JSON>() },
		{ U"layout", emptyLayout }
	};
	connectionsJson[U"rooms"][U"Multiverse"] = JSON{
		{ U"background", U"BG_MULTIVERSE" },
		{ U"interactables", Array<JSON>() },
		{ U"forcusables", Array<JSON>() },
		{ U"layout", emptyLayout }
	};

	// ファイルに保存
	const FilePath jsonPath = FileSystem::PathAppend(m_currentDimensionPath, U"room_connections.json");
	connectionsJson.save(jsonPath);

	// 作成したDimensionをエディタに読み込む
	Load(m_currentDimensionPath + U"/");
}
void DimensionModel::Load(const FilePath& dimensionPath)
{
	if (not FileSystem::IsDirectory(dimensionPath)) {
		return;
	}

	m_currentDimensionPath = dimensionPath;
	m_dimensionName = GetFolderNameFromPath(dimensionPath);
	m_rooms.clear();

	// ロード済みの部屋名を記録するセット
	HashSet<String> loadedRoomNames;

	// room_connections.json を優先してロード
	const FilePath connectionsPath = FileSystem::PathAppend(dimensionPath, U"room_connections.json");
	const JSON connections = JSON::Load(connectionsPath);

	// connectionsが存在し、かつ"rooms"要素を持っている場合
	if (connections && connections.hasElement(U"rooms") && connections[U"rooms"].isObject())
	{
		for (const JSONItem& roomPair : connections[U"rooms"])
		{
			if (roomPair.key.isEmpty())
			{
				continue;
			}

			RoomModel currentRoom;
			currentRoom.name = roomPair.key;
			const FilePath roomDirectory = FileSystem::PathAppend(dimensionPath, currentRoom.name);

			// フォルダが存在するか確認
			if (FileSystem::IsDirectory(roomDirectory))
			{
				// 部屋のフォルダ内の.jsonファイル（オブジェクト）を探す
				for (const auto& filePath : FileSystem::DirectoryContents(roomDirectory))
				{
					if (FileSystem::Extension(filePath) == U"json")
					{
						const String fileName = FileSystem::FileName(filePath);

						if (not fileName.isEmpty())
						{
							currentRoom.objects.push_back({ fileName });
						}
						else
						{
							// 例外を投げる代わりにログ出力に変更
							Logger << U"⚠️ Warning: Found a JSON file with an empty name in room directory: " + roomDirectory;
						}
					}
				}
			}
			else
			{
				Logger << U"⚠️ Warning: Room defined in JSON but directory not found: " << currentRoom.name;
			}

			m_rooms.push_back(currentRoom);
			loadedRoomNames.insert(currentRoom.name);
		}
	}

	// ディレクトリをスキャンし、まだロードされていない（JSONに記載がない、またはJSON自体がない）フォルダがあれば追加
	for (const auto& path : FileSystem::DirectoryContents(dimensionPath))
	{
		if (FileSystem::IsDirectory(path))
		{
			const String roomName = FileSystem::BaseName(path);
			// まだロードされていなければ追加
			if (not loadedRoomNames.contains(roomName))
			{
				RoomModel currentRoom;
				currentRoom.name = roomName;

				// フォルダの中の.jsonファイルを探す
				for (const auto& filePath : FileSystem::DirectoryContents(path))
				{
					if (FileSystem::Extension(filePath) == U"json")
					{
						currentRoom.objects.push_back({ FileSystem::FileName(filePath) });
					}
				}
				m_rooms.push_back(currentRoom);
			}
		}
	}
}

void DimensionModel::CreateNewFocusableFile(const String& roomName, const String& fileName)
{
	if (m_currentDimensionPath.isEmpty())
	{
		return;
	}

	const FilePath roomPath = FileSystem::PathAppend(m_currentDimensionPath, roomName);
	const FilePath newFilePath = FileSystem::PathAppend(roomPath, fileName);

	if (FileSystem::Exists(newFilePath))
	{
		Logger << U"File '{}' already exists."_fmt(fileName);
		return;
	}

	const String objectType = FileSystem::BaseName(fileName);
	JSON templateJson = GetFocusableTemplate(objectType);

	if (templateJson.save(newFilePath))
	{
		Logger << U"✅ Created new focusable file: " << newFilePath;
		Load(m_currentDimensionPath);
	}
	else
	{
		Logger << U"🚨 Failed to create file: " << newFilePath;
	}
}

void DimensionModel::AddNewRoom(const String& roomName)
{
	if (m_currentDimensionPath.isEmpty() || roomName.isEmpty())
	{
		return;
	}

	// 既に同じ名前の部屋がないか確認
	for (const auto& room : m_rooms)
	{
		if (room.name == roomName)
		{
			Logger << U"Room '{}' already exists in model."_fmt(roomName);
			return;
		}
	}

	// 1. ディスク上に新しいフォルダを作成
	const FilePath roomPath = FileSystem::PathAppend(m_currentDimensionPath, roomName);
	if (FileSystem::CreateDirectories(roomPath))
	{
		Logger << U"✅ Created new directory: " << roomPath;
	}

	// 2. メモリ上の部屋リストに追加
	m_rooms.push_back({ .name = roomName, .objects = {} });
}

void DimensionModel::saveJsonForPath(const FilePath& path, const JSON& jsonData)
{
	if (path.isEmpty())
	{
		return;
	}

	if (jsonData.save(path))
	{
		Logger << U"✅ Saved: " << path;
	}
	else
	{
		Logger << U"🚨 Failed to save: " << path;
	}
}

void DimensionModel::addHotspot(const FilePath& targetJsonPath, const JSON& newHotspot)
{
	if (targetJsonPath.isEmpty() || not FileSystem::Exists(targetJsonPath))
	{
		return;
	}

	JSON targetJson = JSON::Load(targetJsonPath);
	if (not targetJson)
	{
		return;
	}

	// "hotspots" 配列がなければ作成
	if (not targetJson.hasElement(U"hotspots"))
	{
		targetJson[U"hotspots"] = Array<JSON>();
	}

	// "hotspots" が配列であることを確認して追加
	if (targetJson[U"hotspots"].isArray())
	{
		targetJson[U"hotspots"].push_back(newHotspot);
		// ファイルに保存
		saveJsonForPath(targetJsonPath, targetJson);
	}
}

--- FILE: C:\Users\KAWAMURA Yuya\source\repos\DimensionEditor\DimensionEditor\Model\DimensionModel.hpp ---


#pragma once
#include <Siv3D.hpp>

// Forcusableオブジェクトのデータ構造
struct FocusableObjectModel
{
	String fileName; // 例: "Lockbox.json"
};

// ルームのデータ構造
struct RoomModel
{
	String name;
	Array<FocusableObjectModel> objects;
};

class DimensionModel
{
public:
	DimensionModel();

	void CreateNew(const FilePath& baseDir, const String& dimensionName);
	void Load(const FilePath& dimensionPath);

	void CreateNewFocusableFile(const String& roomName, const String& fileName);

	void AddNewRoom(const String& roomName);
	
	const String& getDimensionName() const { return m_dimensionName; }
	const Array<RoomModel>& getRooms() const { return m_rooms; }
	bool isDimensionLoaded() const { return (not m_currentDimensionPath.isEmpty()); }
	void saveJsonForPath(const FilePath& path, const JSON& jsonData);

	const FilePath& getCurrentDimensionPath() const { return m_currentDimensionPath; }

	void addHotspot(const FilePath& targetJsonPath, const JSON& newHotspot);



private:
	FilePath m_currentDimensionPath;
	int m_dimensionId;
	String m_dimensionName;
	Array<RoomModel> m_rooms;
};

--- FILE: C:\Users\KAWAMURA Yuya\source\repos\DimensionEditor\DimensionEditor\View\Inspector\GenericDrawer.cpp ---


#include "GenericDrawer.hpp"
#include "../../imgui-s3d-wrapper/imgui/DearImGuiAddon.hpp"
#include "InspectorDrawerUtils.hpp"
#include "../EditorView.hpp"

void GenericDrawer::draw(JSON& jsonData, EditorView&, EditorController&, DimensionModel&)
{
	if (ImGui::CollapsingHeader("Generic Properties", ImGuiTreeNodeFlags_DefaultOpen))
	{
		if (jsonData.isObject())
		{
			Array<String> keys;
			for (const auto& pair : jsonData)
			{
				keys.push_back(pair.key);
			}

			for (const auto& key : keys)
			{
				JSON valueCopy = jsonData[key];
				DrawJsonValueEditor(key, valueCopy, nullptr);
				jsonData[key] = valueCopy;
			}
		}
	}
}

--- FILE: C:\Users\KAWAMURA Yuya\source\repos\DimensionEditor\DimensionEditor\View\Inspector\GenericDrawer.hpp ---


#pragma once
#include "IInspectorDrawer.hpp"

class GenericDrawer : public IInspectorDrawer
{
public:
	void draw(JSON& jsonData, EditorView&, EditorController&, DimensionModel&) override;
};

--- FILE: C:\Users\KAWAMURA Yuya\source\repos\DimensionEditor\DimensionEditor\View\Inspector\IInspectorDrawer.hpp ---


#pragma once
#include <Siv3D.hpp>

class EditorView;
class EditorController;
class DimensionModel;

class IInspectorDrawer
{
public:
	virtual ~IInspectorDrawer() = default;
	virtual void draw(JSON& jsonData, EditorView& editorView, EditorController& controller, DimensionModel& model) = 0;
};

--- FILE: C:\Users\KAWAMURA Yuya\source\repos\DimensionEditor\DimensionEditor\View\Inspector\InspectorDrawerFactory.hpp ---


#pragma once
#include "../../SchemaManager.hpp"
#include "SchemaDrivenDrawer.hpp"
#include "GenericDrawer.hpp"
#include "RoomConnectionsDrawer.hpp"

namespace InspectorDrawerFactory
{
	inline std::unique_ptr<IInspectorDrawer> Create(const String& fileName)
	{
		if (fileName == U"room_connections")
		{
			return std::make_unique<RoomConnectionsDrawer>();
		}

		if (auto schema = GetSchema(fileName))
		{
			return std::make_unique<SchemaDrivenDrawer>(schema.value());
		}
		else
		{
			return std::make_unique<GenericDrawer>();
		}
	}
}

--- FILE: C:\Users\KAWAMURA Yuya\source\repos\DimensionEditor\DimensionEditor\View\Inspector\InspectorDrawerUtils.cpp ---


#include "InspectorDrawerUtils.hpp"
#include "../../SchemaManager.hpp"
#include "../../imgui-s3d-wrapper/imgui/DearImGuiAddon.hpp"

// JSONの値を編集するためのUIを描画する、再帰的なヘルパー関数
void DrawJsonValueEditor(const String& label, JSON& jsonValue, const std::shared_ptr<Schema>& childSchemaHint)
{
	ImGui::PushID(label.narrow().c_str());

	switch (jsonValue.getType())
	{
	case JSONValueType::String:
	{
		char buffer[1024];
		strcpy_s(buffer, jsonValue.getOr<String>(U"").toUTF8().c_str());
		if (ImGui::InputText(label.toUTF8().c_str(), buffer, std::size(buffer)))
		{
			jsonValue = Unicode::FromUTF8(buffer);
		}
		break;
	}
	case JSONValueType::Number:
	{
		double value = jsonValue.getOr<double>(0.0);
		if (ImGui::InputDouble(label.toUTF8().c_str(), &value))
		{
			jsonValue = value;
		}
		break;
	}
	case JSONValueType::Bool:
	{
		bool value = jsonValue.getOr<bool>(false);
		if (ImGui::Checkbox(label.toUTF8().c_str(), &value))
		{
			jsonValue = value;
		}
		break;
	}
	case JSONValueType::Array:
	{
		if (ImGui::TreeNode(label.toUTF8().c_str()))
		{
			int32 removeIndex = -1;

			for (auto&& [i, element] : IndexedRef(jsonValue.arrayView()))
			{
				String elementLabel = label + U"[" + ToString(i) + U"]";

				ImGui::PushID(static_cast<int>(i));

				if (ImGui::Button("-")) { removeIndex = static_cast<int32>(i); }
				ImGui::SameLine();

				if (ImGui::TreeNode(elementLabel.toUTF8().c_str()))
				{
					if (childSchemaHint && element.isObject())
					{
						ImGui::Indent();
						for (const auto& childPair : *childSchemaHint)
						{
							const String& childKey = childPair.first;
							const SchemaProperty& childProp = childPair.second;
							if (element.hasElement(childKey))
							{
								JSON valueCopy = element[childKey];
								DrawJsonValueEditor(childProp.description, valueCopy, childProp.childSchema);
								element[childKey] = valueCopy;
							}
						}
						ImGui::Unindent();
					}
					else
					{
						DrawJsonValueEditor(U"Value", element, nullptr);
					}
					ImGui::TreePop();
				}
				ImGui::PopID();
			}

			if (removeIndex != -1)
			{
				jsonValue.erase(removeIndex);
			}

			if (ImGui::Button("+ Add"))
			{
				if (childSchemaHint)
				{
					JSON newObject;
					// 子スキーマを元に、正しい型のプロパティを追加
					for (const auto& childPair : *childSchemaHint)
					{
						const String& key = childPair.first;
						const SchemaProperty& prop = childPair.second;
						switch (prop.type)
						{
						case JSONValueType::String: newObject[key] = U""; break;
						case JSONValueType::Number: newObject[key] = 0; break;
						case JSONValueType::Bool:   newObject[key] = false; break;
						case JSONValueType::Array:  newObject[key] = Array<JSON>{}; break;
						case JSONValueType::Object: newObject[key] = JSON{}; break;
						default: newObject[key] = JSON(); break;
						}
					}
					jsonValue.push_back(newObject);
				}
				else
				{
					jsonValue.push_back(JSON());
				}
			}
			ImGui::TreePop();
		}
		break;
	}
	case JSONValueType::Object:
	{
		if (ImGui::TreeNode(label.toUTF8().c_str()))
		{
			Array<String> keys;
			for (const auto& pair : jsonValue)
			{
				keys.push_back(pair.key);
			}

			// 取得したキーのリストを使ってループ
			for (const auto& key : keys)
			{
				JSON valueCopy = jsonValue[key];

				if (childSchemaHint && (childSchemaHint->find(key) != childSchemaHint->end()))
				{
					const auto& prop = childSchemaHint->at(key);
					DrawJsonValueEditor(prop.description, valueCopy, prop.childSchema);
				}
				else
				{
					DrawJsonValueEditor(key, valueCopy, nullptr);
				}

				jsonValue[key] = valueCopy;
			}
			ImGui::TreePop();
		}
		break;
	}
	default:
		ImGui::Text((label + U" (Unknown Type)").toUTF8().c_str());
		break;
	}

	ImGui::PopID();
}

--- FILE: C:\Users\KAWAMURA Yuya\source\repos\DimensionEditor\DimensionEditor\View\Inspector\InspectorDrawerUtils.hpp ---


#pragma once
#include <Siv3D.hpp>

struct Schema;

void DrawJsonValueEditor(const String& label, JSON& jsonValue, const std::shared_ptr<Schema>& childSchemaHint);

--- FILE: C:\Users\KAWAMURA Yuya\source\repos\DimensionEditor\DimensionEditor\View\Inspector\RoomConnectionsDrawer.cpp ---


#include "RoomConnectionsDrawer.hpp"
#include "../../SchemaManager.hpp"
#include "../EditorView.hpp"
#include "../../Controller/EditorController.hpp"

void RoomConnectionsDrawer::draw(JSON& jsonData, EditorView& editorView, EditorController& controller, DimensionModel&)
{
	if (not jsonData.hasElement(U"rooms") || not jsonData[U"rooms"].isObject())
	{
		ImGui::Text("Invalid format: 'rooms' object not found.");
		return;
	}

	// ヘッダー
	if (ImGui::CollapsingHeader("Rooms", ImGuiTreeNodeFlags_DefaultOpen))
	{
		String roomToDelete = U""; // 削除対象の部屋名を一時的に保持

		// 既存の部屋をリスト表示
		for (const auto& roomPair : jsonData[U"rooms"])
		{
			const String& roomName = roomPair.key;
			ImGui::PushID(roomName.toUTF8().c_str());

			// 部屋名を表示
			ImGui::BulletText(roomName.toUTF8().c_str());

			ImGui::SameLine(ImGui::GetWindowWidth() - 120); // ボタンを右端に寄せる

			// 編集ボタン
			if (ImGui::Button("Edit"))
			{
				editorView.m_editingRoomName = roomName;
				editorView.m_editingRoomDataCopy = roomPair.value;
				editorView.m_showRoomEditor = true;
			}
			ImGui::SameLine();

			// 削除ボタン
			if (ImGui::Button("Delete"))
			{
				// すぐには削除せず、ループの外で処理するために名前を記録
				roomToDelete = roomName;
			}

			ImGui::PopID();
		}

		// ループの外で安全に要素を削除
		if (not roomToDelete.isEmpty())
		{
			jsonData[U"rooms"].erase(roomToDelete);
		}

		ImGui::Separator();
	}

	// "Add Room"ボタン
	if (ImGui::Button("Add Room...", ImVec2(-1, 0))) // 横幅いっぱいに広げる
	{
		m_newRoomNameBuffer.clear();
		ImGui::OpenPopup("Add New Room");
	}

	// "Add Room"ポップアップの実装
	if (ImGui::BeginPopupModal("Add New Room", NULL, ImGuiWindowFlags_AlwaysAutoResize))
	{
		ImGui::InputText("New Room Name", &m_newRoomNameBuffer);

		if (ImGui::Button("OK", ImVec2(120, 0)))
		{
			if (not m_newRoomNameBuffer.empty())
			{
				const String newRoomName = Unicode::FromUTF8(m_newRoomNameBuffer);

				// 新しい部屋のデフォルトデータをスキーマから生成
				JSON newRoomData;
				for (const auto& propPair : *g_RoomSchema)
				{
					const auto& key = propPair.first;
					const auto& prop = propPair.second;
					if (prop.isRequired) // 必須プロパティのみ初期化
					{
						switch (prop.type)
						{
						case JSONValueType::String: newRoomData[key] = U""; break;
						case JSONValueType::Object: newRoomData[key] = JSON(); break;
						case JSONValueType::Array: newRoomData[key] = Array<JSON>(); break;
						default: break;
						}
					}
				}
				// layoutオブジェクトの必須プロパティも初期化
				newRoomData[U"layout"][U"forcusable"] = Array<JSON>();
				newRoomData[U"layout"][U"interactable"] = Array<JSON>(); 

				jsonData[U"rooms"][newRoomName] = newRoomData;
				controller.addNewRoom(newRoomName);
			}
			ImGui::CloseCurrentPopup();
		}
		ImGui::SameLine();
		if (ImGui::Button("Cancel", ImVec2(120, 0)))
		{
			ImGui::CloseCurrentPopup();
		}
		ImGui::EndPopup();
	}
}

--- FILE: C:\Users\KAWAMURA Yuya\source\repos\DimensionEditor\DimensionEditor\View\Inspector\RoomConnectionsDrawer.hpp ---


#pragma once
#include "IInspectorDrawer.hpp"
#include "../../ImGuiHelpers.hpp"

class RoomConnectionsDrawer : public IInspectorDrawer
{
public:
	void draw(JSON& jsonData, EditorView& editorView, EditorController& controller, DimensionModel&) override;

private:
	std::string m_newRoomNameBuffer;
};

--- FILE: C:\Users\KAWAMURA Yuya\source\repos\DimensionEditor\DimensionEditor\View\Inspector\SchemaDrivenDrawer.cpp ---


#include "SchemaDrivenDrawer.hpp"
#include "../../imgui-s3d-wrapper/imgui/DearImGuiAddon.hpp"
#include "InspectorDrawerUtils.hpp"
#include "../EditorView.hpp"
#include "../../Controller/EditorController.hpp"

namespace
{
	String JSONValueTypeToString(const JSONValueType type)
	{
		switch (type)
		{
		case JSONValueType::String: return U"String";
		case JSONValueType::Number: return U"Number";
		case JSONValueType::Bool:   return U"Bool";
		case JSONValueType::Array:  return U"Array";
		case JSONValueType::Object: return U"Object";
		case JSONValueType::Null:   return U"Null";
		default:                    return U"Unknown";
		}
	}
}

SchemaDrivenDrawer::SchemaDrivenDrawer(const Schema& schema)
	: m_schema(schema)
{
}

void SchemaDrivenDrawer::draw(JSON& jsonData, EditorView& editorView, EditorController& controller, DimensionModel&)
{
	for (const auto& schemaPair : m_schema)
	{
		const String& key = schemaPair.first;
		const SchemaProperty& prop = schemaPair.second;

		if (jsonData.hasElement(key))
		{
			if (key == U"initial_grid")
			{
				if (key == U"initial_grid")
				{
					if (ImGui::TreeNode(prop.description.toUTF8().c_str()))
					{
						if (not jsonData[key].isArray())
						{
							jsonData[key] = Array<JSON>();
						}

						int height = static_cast<int>(jsonData[key].size());
						int width = (height > 0 && jsonData[key][0].isArray()) ? static_cast<int>(jsonData[key][0].size()) : 0;

						int newWidth = width;
						int newHeight = height;

						ImGui::PushID("GridSize");
						ImGui::Text("Size:");
						ImGui::SameLine();
						ImGui::SetNextItemWidth(80);
						if (ImGui::InputInt("W", &newWidth)) { newWidth = Clamp(newWidth, 0, 50); }
						ImGui::SameLine();
						ImGui::SetNextItemWidth(80);
						if (ImGui::InputInt("H", &newHeight)) { newHeight = Clamp(newHeight, 0, 50); }
						ImGui::PopID();

						if (newWidth != width || newHeight != height)
						{
							Array<Array<int>> newGrid(newHeight, Array<int>(newWidth, 0));
							for (int y = 0; y < Min(height, newHeight); ++y)
							{
								for (int x = 0; x < Min(width, newWidth); ++x)
								{
									newGrid[y][x] = jsonData[key][y][x].getOpt<int>().value_or(0);
								}
							}
							jsonData[key] = newGrid;
						}

						ImGui::Separator();
						for (int y = 0; y < newHeight; ++y)
						{
							ImGui::PushID(y);
							for (int x = 0; x < newWidth; ++x)
							{
								bool isChecked = (jsonData[key][y][x].getOpt<int>().value_or(0) == 1);
								std::string cellLabel = "##cell" + ToString(x).narrow();
								if (ImGui::Checkbox(cellLabel.c_str(), &isChecked))
								{
									jsonData[key][y][x] = isChecked ? 1 : 0;
								}
								if (x < newWidth - 1)
								{
									ImGui::SameLine();
								}
							}
							ImGui::PopID();
						}
						ImGui::TreePop();
					}
				}
			}
			else
			{
				// それ以外のプロパティは、従来通りの汎用エディタを呼び出す
				JSON valueCopy = jsonData[key];
				DrawJsonValueEditor(prop.description, valueCopy, prop.childSchema);
				jsonData[key] = valueCopy;
			}
		}
		else if (prop.isRequired)
		{
			const String errorMsg = (prop.description + U" [必須プロパティがありません！]");
			ImGui::TextColored(ImVec4(1.0f, 0.0f, 0.0f, 1.0f), errorMsg.toUTF8().c_str());
		}
	}
}

--- FILE: C:\Users\KAWAMURA Yuya\source\repos\DimensionEditor\DimensionEditor\View\Inspector\SchemaDrivenDrawer.hpp ---


#pragma once
#include "IInspectorDrawer.hpp"
#include "../../SchemaManager.hpp"

class SchemaDrivenDrawer : public IInspectorDrawer
{
public:
	explicit SchemaDrivenDrawer(const Schema& schema);
	void draw(JSON& jsonData, EditorView&, EditorController&, DimensionModel&) override;
private:
	const Schema m_schema;
};

--- FILE: C:\Users\KAWAMURA Yuya\source\repos\DimensionEditor\DimensionEditor\View\EditorView.cpp ---


#include "EditorView.hpp"

#include <Siv3D.hpp>
#define IMGUI_DEFINE_MATH_OPERATORS
#include "../imgui-s3d-wrapper/imgui/DearImGuiAddon.hpp"

#include "../Model/DimensionModel.hpp"
#include "../Controller/EditorController.hpp"

namespace s3d
{
	void Formatter(FormatData& formatData, const JSONItem& item)
	{
		formatData.string += U"JSONItem";
	}
}

// アクションタイプの定義を拡張
namespace
{
	const char* ACTION_TYPES[] = {
		"テキストを表示 (ShowText)",
		"アイテムを入手 (GiveItem)",
		"フラグを操作 (SetFlag)",
		"条件分岐 (Conditional)",
		"連続実行 (Sequence)",
		"ステップ実行 (MultiStep)",
		"次元を移動 (ChangeDimension)"
	};
	enum ActionTypeIndex {
		ActionType_ShowText = 0,
		ActionType_GiveItem,
		ActionType_SetFlag,
		ActionType_Conditional,
		ActionType_Sequence,
		ActionType_MultiStep,
		ActionType_ChangeDimension
	};
}

int EditorView::s_selectedActionTypeIndex = 0;
int EditorView::s_selectedConditionTypeIndex = 0;

JSON createActionTemplate(const String& type);

// Conditionのテンプレートを生成する関数
JSON createConditionTemplate(const String& type)
{
	if (type == U"HasItem")
	{
		return JSON{
			{U"type", U"HasItem"},
			{U"item", U"（アイテムID）"}
		};
	}
	if (type == U"IsFlagOn")
	{
		return JSON{
			{U"type", U"IsFlagOn"},
			{U"flag", U"（フラグ名）"},
			{U"scope", U"Dimension"}
		};
	}
	// デフォルト
	return JSON{ {U"type", U"HasItem"} };
}


// Actionのテンプレートを生成する関数
JSON createActionTemplate(const String& type)
{
	if (type == U"ShowText")
	{
		return JSON{
			{U"type", U"ShowText"},
			{U"file", U"example.txt"}
		};
	}
	if (type == U"GiveItem")
	{
		return JSON{
			{U"type", U"GiveItem"},
			{U"item", U"（アイテムID）"}
		};
	}
	if (type == U"SetFlag")
	{
		return JSON{
			{U"type", U"SetFlag"},
			{U"flag", U"（フラグ名）"},
			{U"value", true},
			{U"scope", U"Dimension"}
		};
	}
	if (type == U"Conditional")
	{
		return JSON{
			{U"type", U"Conditional"},
			{U"condition", createConditionTemplate(U"HasItem")},
			{U"success", createActionTemplate(U"ShowText")},
			{U"failure", createActionTemplate(U"ShowText")}
		};
	}
	if (type == U"Sequence")
	{
		return JSON{
			{U"type", U"Sequence"},
			{U"actions", Array<JSON>()} // 空の配列
		};
	}
	if (type == U"MultiStep")
	{
		return JSON{
			{U"type", U"MultiStep"},
			{U"id", U"（ユニークなID）"},
			{U"steps", Array<JSON>()}, // 空の配列
			{U"final_action", createActionTemplate(U"ShowText")}
		};
	}
	// デフォルト
	return createActionTemplate(U"ShowText");
}

String GridToString(const Point& p)
{
	if (p.x < 0 || p.y < 0) return U"";
	return U"{}{}"_fmt(static_cast<char32>(U'A' + p.y), p.x + 1);
}

String GridRectToString(const Rect& r)
{
	const String start = GridToString(r.pos);
	const String end = GridToString(r.br() - Point{ 1, 1 });

	if (start == end)
	{
		return start;
	}
	return U"{}-{}"_fmt(start, end);
}

EditorView::EditorView()
{
	// デフォルトの作成先パスを設定
	m_newDimensionPathBuffer = "";
}

void EditorView::draw(DimensionModel& model, EditorController& controller)
{
	ImGui::DockSpaceOverViewport(ImGui::GetID("DockSpace"), ImGui::GetMainViewport());
	drawMenuBar(controller);

	if (m_shouldShowNewDimensionPopup)
	{
		ImGui::OpenPopup("Create New Dimension");
		m_shouldShowNewDimensionPopup = false;
	}
	if (m_shouldOpenAddHotspotModal)
	{
		ImGui::OpenPopup("Add New Hotspot");
		m_shouldOpenAddHotspotModal = false;
	}

	drawRoomEditorWindow(controller);
	drawGridSelectorWindow(controller);
	drawAddTransitionWindow(controller);
	drawForcusableEditorWindow(controller);
	drawInteractableEditorWindow(controller);

	if (ImGui::BeginPopupModal("Create New Dimension", NULL, ImGuiWindowFlags_AlwaysAutoResize))
	{
		ImGui::InputText("Name", &m_newDimensionNameBuffer);
		ImGui::InputText("Directory", &m_newDimensionPathBuffer, ImGuiInputTextFlags_ReadOnly);
		ImGui::SameLine();
		if (ImGui::Button("Browse..."))
		{
			if (const auto result = Dialog::SelectFolder(Unicode::FromUTF8(m_newDimensionPathBuffer))) {
				m_newDimensionPathBuffer = result.value().toUTF8();
			}
		}
		if (ImGui::Button("Create", ImVec2(120, 0))) {
			controller.createNewDimension(Unicode::FromUTF8(m_newDimensionNameBuffer), Unicode::FromUTF8(m_newDimensionPathBuffer));
			ImGui::CloseCurrentPopup();
		}
		ImGui::SameLine();
		if (ImGui::Button("Cancel", ImVec2(120, 0))) {
			ImGui::CloseCurrentPopup();
		}
		ImGui::EndPopup();
	}

	drawAddHotspotModal(controller);
	drawHierarchyPanel(model, controller);
	drawCanvasPanel(controller);
	drawInspectorPanel(controller);
}

void EditorView::openInteractableEditor(int index)
{
	if (index == -1) {
		m_isEditingInteractable = false;
		m_interactableDraftState = {};
	}
	else {
		m_isEditingInteractable = true;
		m_editingInteractableIndex = index;
		const auto& item = m_editingRoomDataCopy[U"interactables"][index];
		m_interactableDraftState.nameBuffer = item[U"name"].getOpt<String>().value_or(U"").toUTF8();
		if (item.hasElement(U"default_state")) {
			const auto& defaultState = item[U"default_state"];
			m_interactableDraftState.defaultStateDraft.assetBuffer = defaultState[U"asset"].getOpt<String>().value_or(U"").toUTF8();
			m_interactableDraftState.defaultStateDraft.gridPosBuffer = defaultState[U"grid_pos"].getOpt<String>().value_or(U"").toUTF8();
		}
		if (item.hasElement(U"hotspot")) {
			const auto& hotspot = item[U"hotspot"];
			m_interactableDraftState.hotspotDraft.gridPosBuffer = hotspot[U"grid_pos"].getOpt<String>().value_or(U"").toUTF8();
			if (hotspot.hasElement(U"action")) {
				buildDraftFromActionJson(m_interactableDraftState.hotspotDraft.rootAction, hotspot[U"action"]);
			}
		}
	}
	m_showAddInteractableWindow = (index == -1);
	m_showEditInteractableWindow = (index != -1);
}

void EditorView::openGridSelector(std::string& targetBuffer)
{
	m_gridSelectorTargetBuffer = &targetBuffer;
	m_gridDragStartCell = { -1, -1 };
	m_gridSelectionRect = { -1, -1, -1, -1 };
	m_showGridSelector = true;
}

void EditorView::drawRoomEditorWindow(EditorController& controller)
{
	if (!m_showRoomEditor)
	{
		return;
	}

	String modalTitle = U"Edit Room: {}"_fmt(m_editingRoomName);

	if (ImGui::Begin(modalTitle.toUTF8().c_str(), &m_showRoomEditor))
	{
		//==============================================================================
		// タブUI
		//==============================================================================
		if (ImGui::BeginTabBar("RoomEditorTabs"))
		{
			//--------------------------------------------------------------------------
			// Generalタブ
			//--------------------------------------------------------------------------
			if (ImGui::BeginTabItem("General"))
			{
				if (m_editingRoomDataCopy.hasElement(U"background") && m_editingRoomDataCopy[U"background"].isString())
				{
					std::string bgBuffer = m_editingRoomDataCopy[U"background"].get<String>().toUTF8();
					if (ImGui::InputText("Background Asset", &bgBuffer, ImGuiInputTextFlags_EnterReturnsTrue))
					{
						m_editingRoomDataCopy[U"background"] = Unicode::FromUTF8(bgBuffer);
					}
				}
				ImGui::EndTabItem();
			}

			//--------------------------------------------------------------------------
			// Transitionsタブ
			//--------------------------------------------------------------------------
			if (ImGui::BeginTabItem("Transitions"))
			{
				if (not m_editingRoomDataCopy.hasElement(U"transitions")) { m_editingRoomDataCopy[U"transitions"] = JSON(); }
				String transitionToDelete = U"";

				for (const auto& transPair : m_editingRoomDataCopy[U"transitions"])
				{
					const auto& key = transPair.key;
					const auto& value = transPair.value;
					ImGui::PushID(key.toUTF8().c_str());
					ImGui::Bullet(); ImGui::SameLine();
					if (value.isString())
					{
						ImGui::Text("%s -> %s", key.toUTF8().c_str(), value.get<String>().toUTF8().c_str());
					}
					else if (value.isObject())
					{
						// まず行き先は必ず表示
						ImGui::Text("%s -> %s", key.toUTF8().c_str(), value[U"to"].get<String>().toUTF8().c_str());

						// conditionキーが存在する場合のみ、条件を表示
						if (value.hasElement(U"condition"))
						{
							ImGui::SameLine();
							ImGui::Text(" (if %s is TRUE)", value[U"condition"].get<String>().toUTF8().c_str());
						}
						// grid_posキーが存在する場合のみ、位置を表示
						if (value.hasElement(U"grid_pos"))
						{
							ImGui::SameLine();
							ImGui::Text(" (at %s)", value[U"grid_pos"].get<String>().toUTF8().c_str());
						}
					}

					ImGui::SameLine(ImGui::GetWindowWidth() - 40);
					if (ImGui::SmallButton("X")) { transitionToDelete = key; }
					ImGui::PopID();
				}

				if (not transitionToDelete.isEmpty())
				{
					m_editingRoomDataCopy[U"transitions"].erase(transitionToDelete);
				}
				ImGui::Separator();
				if (ImGui::Button("Add Transition..."))
				{
					m_newTransitionTypeIndex = 0;
					m_newTransitionDirectionIndex = 0;
					m_showAddTransitionWindow = true;
				}
				ImGui::EndTabItem();
			}

			//--------------------------------------------------------------------------
			// Layout & Objectsタブ
			//--------------------------------------------------------------------------
			if (ImGui::BeginTabItem("Layout & Objects"))
			{
				// --- Forcusable Objects ---
				ImGui::Text("Forcusable Objects");
				ImGui::Separator();
				if (not m_editingRoomDataCopy.hasElement(U"forcusables")) { m_editingRoomDataCopy[U"forcusables"] = Array<JSON>(); }

				int focusableIndexToDelete = -1;
				for (size_t i = 0; i < m_editingRoomDataCopy[U"forcusables"].size(); ++i)
				{
					const auto& item = m_editingRoomDataCopy[U"forcusables"][i];
					const String name = item[U"name"].getOpt<String>().value_or(U"");
					ImGui::PushID(static_cast<int>(i) + 1000); // InteractableとIDが衝突しないようにオフセット
					ImGui::BulletText(name.toUTF8().c_str());
					ImGui::SameLine(ImGui::GetWindowWidth() - 120);
					if (ImGui::SmallButton("Edit")) { openForcusableEditor(static_cast<int>(i)); }
					ImGui::SameLine();
					if (ImGui::SmallButton("Delete")) { focusableIndexToDelete = static_cast<int>(i); }
					ImGui::PopID();
				}
				if (focusableIndexToDelete != -1) { m_editingRoomDataCopy[U"forcusables"].erase(focusableIndexToDelete); }
				if (ImGui::Button("Add Forcusable...")) { openForcusableEditor(-1); }

				ImGui::Dummy(ImVec2(0.0f, 20.0f));

				// --- Interactable Objects ---
				ImGui::Text("Interactable Objects");
				ImGui::Separator();
				if (not m_editingRoomDataCopy.hasElement(U"interactables")) { m_editingRoomDataCopy[U"interactables"] = Array<JSON>(); }

				int interactableIndexToDelete = -1;
				for (size_t i = 0; i < m_editingRoomDataCopy[U"interactables"].size(); ++i)
				{
					const auto& item = m_editingRoomDataCopy[U"interactables"][i];
					const String name = item[U"name"].getOpt<String>().value_or(U"");
					ImGui::PushID(static_cast<int>(i));
					ImGui::BulletText(name.toUTF8().c_str());
					ImGui::SameLine(ImGui::GetWindowWidth() - 120);
					if (ImGui::SmallButton("Edit")) { openInteractableEditor(static_cast<int>(i)); }
					ImGui::SameLine();
					if (ImGui::SmallButton("Delete")) { interactableIndexToDelete = static_cast<int>(i); }
					ImGui::PopID();
				}
				if (interactableIndexToDelete != -1) { m_editingRoomDataCopy[U"interactables"].erase(interactableIndexToDelete); }
				if (ImGui::Button("Add Interactable...")) { openInteractableEditor(-1); }

				ImGui::EndTabItem();
			}
			ImGui::EndTabBar();
		}

		//==============================================================================
		// 閉じるボタン
		//==============================================================================
		ImGui::Separator();
		if (ImGui::Button("Apply & Save", ImVec2(120, 0)))
		{
			controller.updateRoomData(m_editingRoomName, m_editingRoomDataCopy);
			controller.saveSelectedJson();
			m_showRoomEditor = false;
		}
		ImGui::SameLine();
		if (ImGui::Button("Cancel", ImVec2(120, 0)))
		{
			m_showRoomEditor = false;
		}

	}
	ImGui::End();
}

void EditorView::drawMenuBar(EditorController& controller)
{
	if (ImGui::BeginMainMenuBar())
	{
		if (ImGui::BeginMenu("File"))
		{
			if (ImGui::MenuItem("New Dimension...")) { m_shouldShowNewDimensionPopup = true; }
			if (ImGui::MenuItem("Open Dimension...")) { controller.openDimension(); }
			if (ImGui::MenuItem("Save")) { controller.saveSelectedJson(); }

			ImGui::EndMenu();
		}
		ImGui::EndMainMenuBar();
	}
}

void EditorView::drawHierarchyPanel(DimensionModel& model, EditorController& controller)
{
	ImGui::Begin("Hierarchy");
	if (model.isDimensionLoaded())
	{
		// 第1階層: Dimension
		const String& dimensionName = model.getDimensionName();
		if (not dimensionName.isEmpty() && ImGui::TreeNode(dimensionName.toUTF8().c_str()))
		{
			const FilePath connectionsPath = model.getCurrentDimensionPath() + U"room_connections.json";
			ImGuiTreeNodeFlags flags = ImGuiTreeNodeFlags_Leaf | ImGuiTreeNodeFlags_NoTreePushOnOpen;
			if (connectionsPath == controller.getSelectedPath())
			{
				flags |= ImGuiTreeNodeFlags_Selected;
			}
			ImGui::TreeNodeEx("room_connections.json", flags);
			if (ImGui::IsItemClicked())
			{
				controller.setSelectedPath(connectionsPath);
			}

			// 第2階層: Room
			for (const auto& room : model.getRooms())
			{
				if (room.name.isEmpty()) continue;

				ImGuiTreeNodeFlags roomNodeFlags = ImGuiTreeNodeFlags_OpenOnArrow;
				if (room.objects.isEmpty())
				{
					roomNodeFlags |= ImGuiTreeNodeFlags_Leaf;
				}

				if (ImGui::TreeNodeEx(room.name.toUTF8().c_str(), roomNodeFlags))
				{
					// 第3階層: Object
					for (const auto& object : room.objects)
					{
						if (object.fileName.isEmpty()) continue;

						ImGuiTreeNodeFlags objectNodeFlags = ImGuiTreeNodeFlags_Leaf | ImGuiTreeNodeFlags_NoTreePushOnOpen;

						const FilePath objectPath = model.getCurrentDimensionPath() + U"/" + room.name + U"/" + object.fileName;
						if (objectPath == controller.getSelectedPath())
						{
							objectNodeFlags |= ImGuiTreeNodeFlags_Selected;
						}

						ImGui::TreeNodeEx(object.fileName.toUTF8().c_str(), objectNodeFlags);
						if (ImGui::IsItemClicked())
						{
							controller.setSelectedPath(objectPath);
						}
					}
					ImGui::TreePop(); 
				}
			}
			ImGui::TreePop();
		}
	}

	if (ImGui::IsMouseClicked(ImGuiMouseButton_Left) && ImGui::IsWindowHovered() && !ImGui::IsAnyItemHovered())
	{
		controller.setSelectedPath(U"");
	}
	ImGui::End();
}

void EditorView::drawCanvasPanel(EditorController& controller)
{
	ImGui::Begin("Canvas");
	const FilePath& selectedPath = controller.getSelectedPath();

	if (FileSystem::Extension(selectedPath) == U"json")
	{
		const JSON& jsonData = controller.getSelectedJsonData();
		if (not jsonData.isEmpty())
		{
			ImGui::TextUnformatted(jsonData.format(2).toUTF8().c_str());
		}
	}
	else
	{
		ImGui::Text("Visual representation of the room here.");
	}
	ImGui::End();
}

void EditorView::drawInspectorPanel(EditorController& controller)
{
	ImGui::Begin("Inspector");

	const FilePath& selectedPath = controller.getSelectedPath();
	DimensionModel& model = controller.getModel();
	
	if (selectedPath != m_lastSelectedPath)
	{
		m_currentDrawer = InspectorDrawerFactory::Create(FileSystem::BaseName(selectedPath));
		m_lastSelectedPath = selectedPath;
	}

	JSON& jsonData = controller.getSelectedJsonData();

	if (m_currentDrawer && (not jsonData.isEmpty()))
	{
		m_currentDrawer->draw(jsonData, *this, controller, model);

		ImGui::Separator();
		// "hotspots" プロパティを持つスキーマの場合のみボタンを表示
		if (m_currentDrawer && jsonData.hasElement(U"hotspots"))
		{
			if (ImGui::Button("Add Hotspot"))
			{
				m_shouldOpenAddHotspotModal = true;
				m_hotspotDraftState = HotspotDraftState{};
			}
		}

		ImGui::Separator();
		if (ImGui::Button("Save Changes"))
		{
			controller.saveSelectedJson();
		}
	}
	else
	{
		ImGui::Text(selectedPath.isEmpty() ? "No file selected." : "This file type is not yet supported.");
	}
	ImGui::End();
}

void EditorView::drawAddHotspotModal(EditorController& controller)
{
	if (ImGui::BeginPopupModal("Add New Hotspot", NULL, ImGuiWindowFlags_AlwaysAutoResize))
	{
		ImGui::Text("クリック範囲 (例: A1-B2)");
		ImGui::InputText("##GridPos", &m_hotspotDraftState.gridPosBuffer);

		ImGui::Separator();

		// 作成したカスタムUI描画関数を呼び出す
		ImGui::PushID("RootAction");
		drawCustomActionEditor(m_hotspotDraftState.rootAction);
		ImGui::PopID();

		ImGui::Separator();
		if (ImGui::Button("OK", ImVec2(120, 0)))
		{
			controller.addNewHotspot(m_hotspotDraftState);
			ImGui::CloseCurrentPopup();
		}
		ImGui::SameLine();
		if (ImGui::Button("Cancel", ImVec2(120, 0)))
		{
			ImGui::CloseCurrentPopup();
		}
		ImGui::EndPopup();
	}
}

void EditorView::drawCustomActionEditor(ActionDraft& draft)
{
	// 拡張したACTION_TYPESを使用
	ImGui::Combo("アクションの種類", &draft.typeIndex, ACTION_TYPES, IM_ARRAYSIZE(ACTION_TYPES));

	ImGui::Separator();

	// 選択された種類に応じて、表示するUIを切り替える
	switch (draft.typeIndex)
	{
	case ActionType_ShowText: // テキストを表示
		ImGui::InputText("テキストファイル", &draft.fileBuffer);
		break;

	case ActionType_GiveItem: // アイテムを入手
		ImGui::InputText("入手するアイテムID", &draft.itemBuffer);
		break;

	case ActionType_SetFlag: // フラグを操作
		ImGui::InputText("操作するフラグ名", &draft.flagBuffer);
		ImGui::Checkbox("フラグをONにする", &draft.flagValue);
		break;

	case ActionType_Conditional: // 条件分岐
	{
		ImGui::Text("もし、");
		ImGui::SameLine();
		const char* conditionTypes[] = { "アイテムを持っているなら", "フラグがONなら" };
		ImGui::Combo("##ConditionType", &draft.conditionTypeIndex, conditionTypes, IM_ARRAYSIZE(conditionTypes));

		if (draft.conditionTypeIndex == 0) // アイテム
		{
			ImGui::InputText("アイテムID", &draft.conditionItemBuffer);
		}
		else // フラグ
		{
			ImGui::InputText("フラグ名", &draft.conditionFlagBuffer);
		}

		if (ImGui::TreeNode("成功した時のアクション"))
		{
			if (!draft.successAction) draft.successAction = std::make_unique<ActionDraft>();
			ImGui::PushID("SuccessAction"); // IDを追加
			drawCustomActionEditor(*draft.successAction);
			ImGui::PopID(); // IDを削除
			ImGui::TreePop();
		}
		if (ImGui::TreeNode("失敗した時のアクション"))
		{
			if (!draft.failureAction) draft.failureAction = std::make_unique<ActionDraft>();
			ImGui::PushID("FailureAction"); // IDを追加
			drawCustomActionEditor(*draft.failureAction);
			ImGui::PopID(); // IDを削除
			ImGui::TreePop();
		}
		break;
	}
	case ActionType_Sequence: // 連続実行
	case ActionType_MultiStep: // ステップ実行
	{
		if (draft.typeIndex == ActionType_MultiStep)
		{
			ImGui::InputText("ステップID (重複不可)", &draft.idBuffer);
			ImGui::Separator();
		}

		const char* listLabel = (draft.typeIndex == ActionType_Sequence) ? "実行リスト" : "ステップリスト";
		if (ImGui::TreeNode(listLabel))
		{
			int indexToRemove = -1;
			// unique_ptrのリストをループ
			for (size_t i = 0; i < draft.actionList.size(); ++i)
			{
				ImGui::PushID(static_cast<int>(i));
				if (ImGui::Button("X"))
				{
					indexToRemove = static_cast<int>(i);
				}
				ImGui::SameLine();

				// std::to_stringを使用してラベルを生成
				if (ImGui::TreeNode(("Action " + std::to_string(i + 1)).c_str()))
				{
					// unique_ptrの中身を参照で渡す
					drawCustomActionEditor(*draft.actionList[i]);
					ImGui::TreePop();
				}
				ImGui::PopID();
			}

			if (indexToRemove != -1)
			{
				draft.actionList.erase(draft.actionList.begin() + indexToRemove);
			}

			if (ImGui::Button("+ 追加"))
			{
				// 新しいActionDraftをunique_ptrで追加
				draft.actionList.push_back(std::make_unique<ActionDraft>());
			}
			ImGui::TreePop();
		}

		// MultiStepの場合、finalActionの編集UIを表示
		if (draft.typeIndex == ActionType_MultiStep)
		{
			ImGui::Separator();
			if (ImGui::TreeNode("完了後のアクション (任意)"))
			{
				if (!draft.finalAction)
				{
					if (ImGui::Button("アクションを設定"))
					{
						draft.finalAction = std::make_unique<ActionDraft>();
					}
				}

				if (draft.finalAction)
				{
					// 削除ボタンが押されたら即座に削除
					if (ImGui::Button("アクションを削除"))
					{
						draft.finalAction.reset();
					}
					// resetされていなければ編集UIを表示
					else
					{
						ImGui::PushID("FinalAction");
						drawCustomActionEditor(*draft.finalAction);
						ImGui::PopID();
					}
				}
				ImGui::TreePop();
			}
		}
		break;
	}
	case ActionType_ChangeDimension:
	{
		ImGui::InputText("ターゲット次元ID", &draft.targetDimensionBuffer);
		break;
	}
	}
}

void EditorView::buildDraftFromActionJson(ActionDraft& draft, const JSON& json)
{
	if (not json.isObject()) return;

	const String type = json[U"type"].getOpt<String>().value_or(U"");

	if (type == U"ShowText")
	{
		draft.typeIndex = ActionType_ShowText;
		draft.fileBuffer = json[U"file"].getOpt<String>().value_or(U"").toUTF8();
	}
	else if (type == U"GiveItem")
	{
		draft.typeIndex = ActionType_GiveItem;
		draft.itemBuffer = json[U"item"].getOpt<String>().value_or(U"").toUTF8();
	}
	else if (type == U"SetFlag")
	{
		draft.typeIndex = ActionType_SetFlag;
		draft.flagBuffer = json[U"flag"].getOpt<String>().value_or(U"").toUTF8();
		draft.flagValue = json[U"value"].getOpt<bool>().value_or(false);
	}
	else if (type == U"Conditional")
	{
		draft.typeIndex = ActionType_Conditional;
		if (json.hasElement(U"condition"))
		{
			const auto& cond = json[U"condition"];
			if (cond[U"type"].getOpt<String>().value_or(U"") == U"HasItem")
			{
				draft.conditionTypeIndex = 0;
				draft.conditionItemBuffer = cond[U"item"].getOpt<String>().value_or(U"").toUTF8();
			}
			else
			{
				draft.conditionTypeIndex = 1;
				draft.conditionFlagBuffer = cond[U"flag"].getOpt<String>().value_or(U"").toUTF8();
			}
		}

		if (json.hasElement(U"success"))
		{
			draft.successAction = std::make_unique<ActionDraft>();
			buildDraftFromActionJson(*draft.successAction, json[U"success"]);
		}
		if (json.hasElement(U"failure"))
		{
			draft.failureAction = std::make_unique<ActionDraft>();
			buildDraftFromActionJson(*draft.failureAction, json[U"failure"]);
		}
	}
	else if (type == U"Sequence" || type == U"MultiStep")
	{
		draft.typeIndex = (type == U"Sequence") ? ActionType_Sequence : ActionType_MultiStep;
		const String listKey = (type == U"Sequence") ? U"actions" : U"steps";

		if (type == U"MultiStep")
		{
			draft.idBuffer = json[U"id"].getOpt<String>().value_or(U"").toUTF8();
			if (json.hasElement(U"final_action"))
			{
				draft.finalAction = std::make_unique<ActionDraft>();
				buildDraftFromActionJson(*draft.finalAction, json[U"final_action"]);
			}
		}

		if (json.hasElement(listKey))
		{
			for (const auto& action : json[listKey])
			{
				auto subDraft = std::make_unique<ActionDraft>();
				buildDraftFromActionJson(*subDraft, action);
				draft.actionList.push_back(std::move(subDraft));
			}
		}
	}
	else if (type == U"ChangeDimension")
	{
		draft.typeIndex = ActionType_ChangeDimension;
		draft.targetDimensionBuffer = json[U"target"].getOpt<String>().value_or(U"").toUTF8();
	}
}

void EditorView::drawGridSelectorWindow(EditorController& controller)
{
	// 表示フラグがfalseなら、この先の処理は行わない
	if (!m_showGridSelector)
	{
		return;
	}

	// 第2引数に表示フラグの参照を渡すことで、「×」ボタンでウィンドウが閉じられる
	if (ImGui::Begin("Grid Selector", &m_showGridSelector, ImGuiWindowFlags_AlwaysAutoResize))
	{
		const int cols = 16;
		const int rows = 12;
		const float cellSize = 20.0f;
		const ImVec2 buttonSize(cellSize, cellSize);
		const ImVec4 selectColor(0.2f, 0.6f, 1.0f, 0.8f);
		const ImGuiIO& io = ImGui::GetIO();

		// ImGui::GetWindowDrawList()はBegin/Endの内側で呼ぶのが安全
		ImDrawList* drawList = ImGui::GetWindowDrawList();
		const ImVec2 p = ImGui::GetCursorScreenPos();

		ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(0, 0));

		for (int y = 0; y < rows; ++y)
		{
			for (int x = 0; x < cols; ++x)
			{
				ImGui::PushID(y * cols + x);
				ImGui::InvisibleButton("cell", buttonSize);
				if (ImGui::IsItemClicked())
				{
					if (io.KeyShift)
					{
						if (m_gridDragStartCell.x == -1)
						{
							m_gridDragStartCell = { x, y };
							m_gridSelectionRect.set(x, y, 1, 1);
						}
						else
						{
							Point start = m_gridDragStartCell;
							Point end = { x, y };
							m_gridSelectionRect.set(Min(start.x, end.x), Min(start.y, end.y), Abs(start.x - end.x) + 1, Abs(start.y - end.y) + 1);
							m_gridDragStartCell = { -1, -1 };
						}
					}
					else
					{
						m_gridDragStartCell = { -1, -1 };
						m_gridSelectionRect.set(x, y, 1, 1);
					}
				}
				if (x < cols - 1)
				{
					ImGui::SameLine();
				}
				ImGui::PopID();
			}
		}
		ImGui::PopStyleVar();

		for (int y = 0; y <= rows; ++y) { drawList->AddLine(ImVec2(p.x, p.y + y * cellSize), ImVec2(p.x + cols * cellSize, p.y + y * cellSize), IM_COL32(100, 100, 100, 255)); }
		for (int x = 0; x <= cols; ++x) { drawList->AddLine(ImVec2(p.x + x * cellSize, p.y), ImVec2(p.x + x * cellSize, p.y + rows * cellSize), IM_COL32(100, 100, 100, 255)); }
		if (m_gridSelectionRect.x != -1)
		{
			ImVec2 r_min(p.x + m_gridSelectionRect.x * cellSize, p.y + m_gridSelectionRect.y * cellSize);
			ImVec2 r_max(r_min.x + m_gridSelectionRect.w * cellSize, r_min.y + m_gridSelectionRect.h * cellSize);
			drawList->AddRectFilled(r_min, r_max, ImGui::GetColorU32(selectColor));
		}
		ImGui::Separator();
		if (ImGui::Button("OK", ImVec2(120, 0)))
		{
			if (m_gridSelectorTargetBuffer && m_gridSelectionRect.x != -1)
			{
				*m_gridSelectorTargetBuffer = GridRectToString(m_gridSelectionRect).toUTF8();
			}
			m_showGridSelector = false;
		}
		ImGui::SameLine();

		if (ImGui::Button("Cancel", ImVec2(120, 0)))
		{
			m_showGridSelector = false;
		}
	}
	ImGui::End();
}

void EditorView::drawAddTransitionWindow(EditorController& controller)
{
	// 表示フラグがfalseなら何もしない
	if (!m_showAddTransitionWindow)
	{
		return;
	}

	// BeginPopupModal から Begin に変更
	if (ImGui::Begin("Add New Transition", &m_showAddTransitionWindow, ImGuiWindowFlags_AlwaysAutoResize))
	{
		ImGui::Text("New Transition");
		ImGui::Separator();
		const char* directions[] = { "Up", "Down", "Left", "Right", "Forward" };
		ImGui::Combo("Direction", &m_newTransitionDirectionIndex, directions, IM_ARRAYSIZE(directions));

		// "Forward"が選択されている時だけ、grid_posの入力欄を表示
		if (strcmp(directions[m_newTransitionDirectionIndex], "Forward") == 0)
		{
			// テキスト入力を読み取り専用にし、「Select...」ボタンを追加
			ImGui::InputText("Grid Position", &m_newTransitionGridPosBuffer, ImGuiInputTextFlags_ReadOnly);
			ImGui::SameLine();
			if (ImGui::Button("Select...##TransitionGrid"))
			{
				m_gridSelectorTargetBuffer = &m_newTransitionGridPosBuffer;
				m_showGridSelector = true;
			}
		}

		ImGui::InputText("To (Room Name)", &m_newTransitionToBuffer);
		const char* types[] = { "Simple", "Conditional" };
		ImGui::Combo("Type", &m_newTransitionTypeIndex, types, IM_ARRAYSIZE(types));
		if (m_newTransitionTypeIndex == 1) // Conditional
		{
			ImGui::InputText("Condition (Flag Name)", &m_newTransitionConditionBuffer);
			const char* scopes[] = { "Dimension", "Global" };
			ImGui::Combo("Scope", &m_newTransitionScopeIndex, scopes, IM_ARRAYSIZE(scopes));
		}
		if (ImGui::Button("OK"))
		{
			const String direction = Unicode::FromUTF8(directions[m_newTransitionDirectionIndex]);
			const String to = Unicode::FromUTF8(m_newTransitionToBuffer);

			if (not to.isEmpty())
			{
				bool isComplex = false;
				JSON transitionObj;
				transitionObj[U"to"] = to;

				// Conditionalかどうか
				if (m_newTransitionTypeIndex == 1) // Conditional
				{
					const String condition = Unicode::FromUTF8(m_newTransitionConditionBuffer);
					if (not condition.isEmpty())
					{
						isComplex = true;
						transitionObj[U"condition"] = condition;
						const char* scopes[] = { "Dimension", "Global" };
						transitionObj[U"scope"] = Unicode::FromUTF8(scopes[m_newTransitionScopeIndex]);
					}
				}

				// Forwardかつgrid_posが指定されているか
				if (direction == U"Forward" && not m_newTransitionGridPosBuffer.empty())
				{
					isComplex = true;
					transitionObj[U"grid_pos"] = Unicode::FromUTF8(m_newTransitionGridPosBuffer);
				}

				if (isComplex)
				{
					// conditionやgrid_posが指定された場合は、オブジェクトとして保存
					m_editingRoomDataCopy[U"transitions"][direction] = transitionObj;
				}
				else
				{
					// それ以外の場合は、単純な文字列として保存
					m_editingRoomDataCopy[U"transitions"][direction] = to;
				}
			}
			m_showAddTransitionWindow = false;
		}
	}
	// Beginに対応するEndを呼ぶ
	ImGui::End();
}

void EditorView::openForcusableEditor(int index)
{
	if (index == -1) {
		m_isEditingForcusable = false;
		m_forcusableDraftState = {};
	}
	else {
		m_isEditingForcusable = true;
		m_editingForcusableIndex = index;
		const auto& item = m_editingRoomDataCopy[U"forcusables"][index];
		m_forcusableDraftState.nameBuffer = item[U"name"].getOpt<String>().value_or(U"").toUTF8();
		m_forcusableDraftState.defaultStateDraft.assetBuffer = item[U"default_state"][U"asset"].getOpt<String>().value_or(U"").toUTF8();
		m_forcusableDraftState.hotspotGridPosBuffer = item[U"hotspot"][U"grid_pos"].getOpt<String>().value_or(U"").toUTF8();
	}
	m_showAddForcusableWindow = (index == -1);
	m_showEditForcusableWindow = (index != -1);
}

void EditorView::drawForcusableEditorWindow(EditorController& controller)
{
	if (!m_showAddForcusableWindow && !m_showEditForcusableWindow) return;
	const char* title = m_isEditingForcusable ? "Edit Forcusable" : "Add New Forcusable";
	bool& show_flag = m_isEditingForcusable ? m_showEditForcusableWindow : m_showAddForcusableWindow;
	if (ImGui::Begin(title, &show_flag, ImGuiWindowFlags_AlwaysAutoResize)) {
		ImGui::InputText("Name (Unique ID)", &m_forcusableDraftState.nameBuffer);
		if (ImGui::CollapsingHeader("Default State", ImGuiTreeNodeFlags_DefaultOpen)) {
			ImGui::InputText("Asset Name", &m_forcusableDraftState.defaultStateDraft.assetBuffer);
		}
		if (ImGui::CollapsingHeader("Hotspot", ImGuiTreeNodeFlags_DefaultOpen)) {
			ImGui::InputText("Grid Position", &m_forcusableDraftState.hotspotGridPosBuffer, ImGuiInputTextFlags_ReadOnly);
			ImGui::SameLine();
			if (ImGui::Button("Select...")) {
				openGridSelector(m_forcusableDraftState.hotspotGridPosBuffer);
			}
		}
		ImGui::Separator();
		if (ImGui::Button("OK")) {
			if (m_isEditingForcusable) {
				controller.updateFocusable(m_editingRoomName, m_editingForcusableIndex, m_forcusableDraftState);
			}
			else {
				controller.addNewFocusable(m_editingRoomName, m_forcusableDraftState);
			}
			show_flag = false;
		}
		ImGui::SameLine();
		if (ImGui::Button("Cancel")) {
			show_flag = false;
		}
	}
	ImGui::End();
}

void EditorView::drawInteractableEditorWindow(EditorController& controller)
{
	if (!m_showAddInteractableWindow && !m_showEditInteractableWindow) return;
	const char* title = m_isEditingInteractable ? "Edit Interactable" : "Add New Interactable";
	bool& show_flag = m_isEditingInteractable ? m_showEditInteractableWindow : m_showAddInteractableWindow;
	if (ImGui::Begin(title, &show_flag, ImGuiWindowFlags_AlwaysAutoResize)) {
		ImGui::InputText("Name (Unique ID)", &m_interactableDraftState.nameBuffer);
		if (ImGui::CollapsingHeader("Default State", ImGuiTreeNodeFlags_DefaultOpen)) {
			ImGui::InputText("Asset Name", &m_interactableDraftState.defaultStateDraft.assetBuffer);
			ImGui::InputText("Grid Position", &m_interactableDraftState.defaultStateDraft.gridPosBuffer, ImGuiInputTextFlags_ReadOnly);
			ImGui::SameLine();
			if (ImGui::Button("Select...##Layout")) {
				openGridSelector(m_interactableDraftState.defaultStateDraft.gridPosBuffer);
			}
		}
		if (ImGui::CollapsingHeader("Hotspot Settings", ImGuiTreeNodeFlags_DefaultOpen)) {
			ImGui::InputText("Hotspot Grid Position", &m_interactableDraftState.hotspotDraft.gridPosBuffer, ImGuiInputTextFlags_ReadOnly);
			ImGui::SameLine();
			if (ImGui::Button("Select...##Hotspot")) {
				openGridSelector(m_interactableDraftState.hotspotDraft.gridPosBuffer);
			}
			ImGui::Separator();
			ImGui::Text("Action");
			drawCustomActionEditor(m_interactableDraftState.hotspotDraft.rootAction);
		}
		ImGui::Separator();
		if (ImGui::Button("OK", ImVec2(120, 0))) {
			if (not m_interactableDraftState.nameBuffer.empty()) {
				if (m_isEditingInteractable) { controller.updateInteractable(m_editingRoomName, m_editingInteractableIndex, m_interactableDraftState); }
				else { controller.addNewInteractable(m_editingRoomName, m_interactableDraftState); }
			}
			show_flag = false;
		}
		ImGui::SameLine();
		if (ImGui::Button("Cancel", ImVec2(120, 0))) {
			show_flag = false;
		}
	}
	ImGui::End();
}

--- FILE: C:\Users\KAWAMURA Yuya\source\repos\DimensionEditor\DimensionEditor\View\EditorView.hpp ---


#pragma once
#include "Inspector/InspectorDrawerFactory.hpp"
#include "../ImGuiHelpers.hpp"
#include "../Controller/EditorDrafts.hpp"
#include "../SchemaManager.hpp"

class DimensionModel;
class EditorController;

class EditorView
{
public:
	EditorView();
	void draw(DimensionModel& model, EditorController& controller);

	// 部屋編集モーダルの状態
	JSON m_editingRoomDataCopy;
	String m_editingRoomName;
	bool m_showRoomEditor = false;

private:
	void drawMenuBar(EditorController& controller);

	void drawHierarchyPanel(DimensionModel& model, EditorController& controller);

	void drawCanvasPanel(EditorController& controller);

	void drawInspectorPanel(EditorController& controller);

	void drawAddHotspotModal(EditorController& controller);

	void openInteractableEditor(int index=-1);

	void openGridSelector(std::string& targetBuffer);

	void drawRoomEditorWindow(EditorController& controller);

	void drawCustomActionEditor(ActionDraft& draft);

	void buildDraftFromActionJson(ActionDraft& draft, const JSON& json);

	void drawGridSelectorWindow(EditorController& controller);

	void drawAddTransitionWindow(EditorController& controller);

	void drawInteractableEditorWindow(EditorController& controller);

	void openForcusableEditor(int index = -1);

	void drawForcusableEditorWindow(EditorController& controller);

	static int s_selectedActionTypeIndex;
	static int s_selectedConditionTypeIndex;

	// ポップアップ内部で使う状態変数
	int m_newTransitionTypeIndex = 0;
	int m_newTransitionDirectionIndex = 0;
	std::string m_newTransitionToBuffer;
	std::string m_newTransitionConditionBuffer;
	int m_newTransitionScopeIndex = 0;

	std::string m_editingFocusableName;
	std::string m_newFocusableNameBuffer;
	std::string m_newFocusableGridPosBuffer;

	InteractableDraftState m_interactableDraftState;
	bool m_isEditingInteractable = false;
	int m_editingInteractableIndex = -1;

	// グリッドセレクタの状態
	std::string* m_gridSelectorTargetBuffer = nullptr;
	s3d::Point m_gridDragStartCell = { -1, -1 };
	s3d::Rect m_gridSelectionRect = { -1, -1, -1, -1 };

	// その他の状態変数
	bool m_shouldShowNewDimensionPopup = false;
	std::string m_newDimensionPathBuffer;
	std::string m_newDimensionNameBuffer = "dimension";
	bool m_shouldOpenAddHotspotModal = false;
	HotspotDraftState m_hotspotDraftState;
	std::unique_ptr<IInspectorDrawer> m_currentDrawer;
	FilePath m_lastSelectedPath;

	bool m_shouldShowInteractablePopup = false;
	bool m_shouldShowEditFocusablePopup = false;
	bool m_shouldShowAddTransitionPopup = false;
	bool m_shouldShowAddFocusablePopup = false;
	bool m_shouldShowGridSelectorPopup = false;

	
	bool m_showAddTransitionWindow = false;
	bool m_showAddFocusable = false;
	bool m_showGridSelector = false;
	bool m_showAddFocusableWindow = false;
	bool m_showEditFocusableWindow = false;
	bool m_showAddInteractableWindow = false;
	bool m_showEditInteractableWindow = false;

	std::string m_newTransitionGridPosBuffer;

	ForcusableDraftState m_forcusableDraftState;
	bool m_isEditingForcusable = false;
	int m_editingForcusableIndex = -1;

	bool m_showAddForcusableWindow = false;
	bool m_showEditForcusableWindow = false;
};

--- FILE: C:\Users\KAWAMURA Yuya\source\repos\DimensionEditor\DimensionEditor\ImGuiHelpers.hpp ---


#pragma once
#include <string>
#include "imgui-s3d-wrapper/imgui/DearImGuiAddon.hpp"

namespace ImGui
{
	// std::string用のコールバックデータを保持する構造体
	struct InputTextCallback_UserData
	{
		std::string* Str;
		ImGuiInputTextCallback  ChainCallback;
		void* ChainCallbackUserData;
	};

	// std::stringのサイズ変更を処理するコールバック関数
	static int InputTextCallback(ImGuiInputTextCallbackData* data)
	{
		InputTextCallback_UserData* user_data = (InputTextCallback_UserData*)data->UserData;
		if (data->EventFlag == ImGuiInputTextFlags_CallbackResize)
		{
			// Resize string callback
			std::string* str = user_data->Str;
			IM_ASSERT(data->Buf == str->c_str());
			str->resize(data->BufTextLen);
			data->Buf = (char*)str->c_str();
		}
		else if (user_data->ChainCallback)
		{
			// Forward to user callback, if any
			data->UserData = user_data->ChainCallbackUserData;
			return user_data->ChainCallback(data);
		}
		return 0;
	}

	// std::stringを受け取るInputTextのオーバーロード
	// エラーの原因となったパラメータ名 (flags, callback, user_data) を正しく定義
	inline bool InputText(const char* label, std::string* str, ImGuiInputTextFlags flags = 0, ImGuiInputTextCallback callback = nullptr, void* user_data = nullptr)
	{
		IM_ASSERT((flags & ImGuiInputTextFlags_CallbackResize) == 0);
		flags |= ImGuiInputTextFlags_CallbackResize;

		InputTextCallback_UserData cb_user_data;
		cb_user_data.Str = str;
		cb_user_data.ChainCallback = callback;
		cb_user_data.ChainCallbackUserData = user_data;

		// 標準の(char*, size_t)版のInputTextを呼び出す。
		// バッファサイズとして capacity() + 1 を渡し、std::stringの内部バッファを直接利用する。
		return InputText(label, (char*)str->c_str(), str->capacity() + 1, flags, InputTextCallback, &cb_user_data);
	}
}

--- FILE: C:\Users\KAWAMURA Yuya\source\repos\DimensionEditor\DimensionEditor\Main.cpp ---


#include <Siv3D.hpp>
#define IMGUI_DEFINE_MATH_OPERATORS
#include "imgui-s3d-wrapper/imgui/DearImGuiAddon.hpp"

#include "Model/DimensionModel.hpp"
#include "View/EditorView.hpp"
#include "Controller/EditorController.hpp"

void Main()
{
	Window::SetTitle(U"Dimension Editor");
	Window::Resize(1280, 720);
	Scene::SetBackground(Palette::White);

	// Siv3DのアドオンとしてImGuiを登録
	Addon::Register<DearImGuiAddon>(U"ImGui");

	// ImGuiのコンテキストを取得して、ドッキングを有効化
	auto& io = ImGui::GetIO();
	io.ConfigFlags |= ImGuiConfigFlags_DockingEnable;

	InitializeSchemas();
	InitializeRecursiveSchemas();


	DimensionModel model;
	EditorController controller{ model };
	EditorView view;

	while (System::Update())
	{
		// Controllerで入力を処理し、Modelを更新
		controller.update();

		// ViewがModelの状態を描画
		view.draw(model, controller);
	}
}

--- FILE: C:\Users\KAWAMURA Yuya\source\repos\DimensionEditor\DimensionEditor\SchemaManager.hpp ---


#pragma once
#include <Siv3D.hpp>

struct Schema;

// プロパティが持つべき情報の定義
struct SchemaProperty
{
	String description;       // プロパティの説明（例：「背景画像」）
	JSONValueType type;       // 期待される型（文字列、数値、配列など）
	bool isRequired;          // このプロパティが必須かどうか

	std::shared_ptr<Schema> childSchema = nullptr;
};

// スキーマ本体（プロパティ名の辞書）
struct Schema : HashTable<String, SchemaProperty>
{
	using HashTable<String, SchemaProperty>::HashTable;
};


inline const auto g_ConditionSchema = std::make_shared<Schema>(Schema{
	{ U"type", { U"Type", JSONValueType::String, true, nullptr } },
	// "HasItem" の場合
	{ U"item", { U"Item ID", JSONValueType::String, false, nullptr } },
	// "IsFlagOn" の場合
	{ U"flag", { U"Flag Name", JSONValueType::String, false, nullptr } },
	{ U"scope", { U"Scope (Global/Dimension)", JSONValueType::String, false, nullptr } },
});

inline std::shared_ptr<Schema> g_ActionSchema = std::make_shared<Schema>();

inline void InitializeSchemas()
{
	*g_ActionSchema = {
		{ U"type", { U"Type", JSONValueType::String, true, nullptr } },
		{ U"file", { U"Text File Path", JSONValueType::String, false, nullptr } },
		{ U"item", { U"Item ID", JSONValueType::String, false, nullptr } },
		{ U"flag", { U"Flag Name", JSONValueType::String, false, nullptr } },
		{ U"value", { U"Set Value", JSONValueType::Bool, false, nullptr } },
		{ U"scope", { U"Scope", JSONValueType::String, false, nullptr } },
		{ U"id", { U"MultiStep ID", JSONValueType::String, false, nullptr } },
		{ U"condition", { U"Condition", JSONValueType::Object, false, g_ConditionSchema } },
		{ U"success", { U"Success Action", JSONValueType::Object, false, g_ActionSchema } },
		{ U"failure", { U"Failure Action", JSONValueType::Object, false, g_ActionSchema } },
		{ U"final_action", { U"Final Action", JSONValueType::Object, false, g_ActionSchema } },
		{ U"actions", { U"Action Sequence", JSONValueType::Array, false, g_ActionSchema } },
		{ U"steps", { U"Multi-Step Actions", JSONValueType::Array, false, g_ActionSchema } },
	};
}

inline void InitializeRecursiveSchemas()
{
	auto& actionSchemaRef = const_cast<Schema&>(*g_ActionSchema);
	actionSchemaRef[U"success"].childSchema = g_ActionSchema;
	actionSchemaRef[U"failure"].childSchema = g_ActionSchema;
	actionSchemaRef[U"actions"].childSchema = g_ActionSchema;
	actionSchemaRef[U"steps"].childSchema = g_ActionSchema;
	actionSchemaRef[U"final_action"].childSchema = g_ActionSchema;
}

// "asset" と "grid_pos" を持つ、オブジェクトの基本的な状態スキーマ
inline const auto g_ObjectStateSchema = std::make_shared<Schema>(Schema{
	{ U"asset", { U"Asset Name", JSONValueType::String, true, nullptr } },
	{ U"grid_pos", { U"Grid Position", JSONValueType::String, false, nullptr } },
});

// "condition_flag" を持つ、条件付きの状態スキーマ
inline const auto g_ConditionalStateSchema = std::make_shared<Schema>(Schema{
	{ U"condition_flag", { U"Condition Flag", JSONValueType::String, true, nullptr } },
	{ U"asset", { U"Asset Name", JSONValueType::String, true, nullptr } },
	{ U"grid_pos", { U"Grid Position", JSONValueType::String, false, nullptr } },
});

inline const auto g_HotspotSchema = std::make_shared<Schema>(Schema{
	{ U"grid_pos", { U"Position (e.g., A1-B2)", JSONValueType::String, true, nullptr } },
	{ U"action", { U"Action", JSONValueType::Object, true, g_ActionSchema } }
});

inline const auto g_MissingPieceSchema = std::make_shared<Schema>(Schema{
		{ U"position", { U"Position [x, y]", JSONValueType::Array, true, nullptr } },
		{ U"item", { U"Required Item ID", JSONValueType::String, true, nullptr } }
	});

inline const auto g_CardCaseAnswerSchema = std::make_shared<Schema>(Schema{
	{ U"code", { U"Code (Array of numbers)", JSONValueType::Array, true, nullptr } },
	{ U"flag", { U"Flag to set on success", JSONValueType::String, true, nullptr } }
});

inline const auto g_LockboxAnswerSchema = std::make_shared<Schema>(Schema{
	{ U"code", { U"Code", JSONValueType::String, true, nullptr } },
	{ U"item", { U"Reward Item", JSONValueType::String, true, nullptr } }
});

inline const auto g_RoomSchema = std::make_shared<Schema>(Schema{
	{ U"background", { U"Background Asset", JSONValueType::String, true, nullptr } },
	{ U"transitions", { U"Room Transitions", JSONValueType::Object, false, nullptr } },
	{ U"interactables", { U"Interactable Objects", JSONValueType::Array, false, nullptr /* g_InteractableSchema */ } }, // 再帰定義を避けるため、実際のchildSchemaはInitialize関数で設定
});

// Interactableオブジェクトのスキーマ
inline const auto g_InteractableSchema = std::make_shared<Schema>(Schema{
	{ U"name", { U"Object Name (Unique)", JSONValueType::String, true, nullptr } },
	{ U"asset", { U"Texture Asset Name", JSONValueType::String, true, nullptr } },
	{ U"hotspot", { U"Hotspot", JSONValueType::Object, true, g_HotspotSchema } },
});

// Forcusableオブジェクトのレイアウトスキーマ
inline const auto g_ForcusableLayoutSchema = std::make_shared<Schema>(Schema{
	// 例: { "Whiteboard": "D3" }
	// キー: Forcusableのファイル名(拡張子なし), 値: グリッド座標
});

// Interactableオブジェクトのレイアウトスキーマ
inline const auto g_InteractableLayoutSchema = std::make_shared<Schema>(Schema{
	// 例: { "Window": "D3-E3" }
	// キー: Interactableのname, 値: グリッド座標
});

// レイアウト全体のスキーマ
inline const auto g_LayoutSchema = std::make_shared<Schema>(Schema{
	{ U"forcusable", { U"Focusable Objects", JSONValueType::Object, true, g_ForcusableLayoutSchema } },
	{ U"interactable", { U"Interactable Objects", JSONValueType::Object, true, g_InteractableLayoutSchema } }
});

// 条件付きTransitionオブジェクトのスキーマ
inline const auto g_ConditionalTransitionSchema = std::make_shared<Schema>(Schema{
	{ U"to", { U"Destination Room", JSONValueType::String, true, nullptr } },
	{ U"condition", { U"Required Flag", JSONValueType::String, true, nullptr } },
	{ U"scope", { U"Flag Scope", JSONValueType::String, true, nullptr } }
});

inline const HashTable<String, Schema> g_Schemas = {
		{
			U"room_connections", *g_RoomSchema
		},
		{
			U"Whiteboard", {
				{ U"name", { U"Object Name", JSONValueType::String, true, nullptr } },
				{ U"hotspot", { U"Hotspot", JSONValueType::Object, true, nullptr /* g_HotspotSchema */ } },
				{ U"default_state", { U"Default State", JSONValueType::Object, true, g_ObjectStateSchema } },
				{ U"states", { U"Conditional States", JSONValueType::Array, false, g_ConditionalStateSchema } },
			}
		},
		{
			U"Lockbox", {
				{ U"name", { U"Object Name", JSONValueType::String, true, nullptr } },
				{ U"hotspot", { U"Hotspot", JSONValueType::Object, true, nullptr /* g_HotspotSchema */ } },
				{ U"default_state", { U"Default State", JSONValueType::Object, true, g_ObjectStateSchema } },
				{ U"states", { U"Conditional States", JSONValueType::Array, false, g_ConditionalStateSchema } },
				{ U"answers", { U"Answer List", JSONValueType::Array, true, g_LockboxAnswerSchema } }
			}
		},
		{
			U"Corpse", {
				{ U"name", { U"Object Name", JSONValueType::String, true, nullptr } },
				{ U"hotspot", { U"Hotspot", JSONValueType::Object, true, nullptr /* g_HotspotSchema */ } },
				{ U"default_state", { U"Default State", JSONValueType::Object, true, g_ObjectStateSchema } },
				{ U"states", { U"Conditional States", JSONValueType::Array, false, g_ConditionalStateSchema } },
			}
		},
		{
			U"Diary", {
				{ U"name", { U"Object Name", JSONValueType::String, true, nullptr } },
				{ U"hotspot", { U"Hotspot", JSONValueType::Object, true, nullptr /* g_HotspotSchema */ } },
				{ U"default_state", { U"Default State", JSONValueType::Object, true, g_ObjectStateSchema } },
				{ U"states", { U"Conditional States", JSONValueType::Array, false, g_ConditionalStateSchema } },
				{ U"pages", { U"Diary Pages (Array of Strings)", JSONValueType::Array, true, nullptr } },
			}
		},
		{
			U"Famicom", {
				{ U"name", { U"Object Name", JSONValueType::String, true, nullptr } },
				{ U"hotspot", { U"Hotspot", JSONValueType::Object, true, nullptr /* g_HotspotSchema */ } },
				{ U"default_state", { U"Default State", JSONValueType::Object, true, g_ObjectStateSchema } },
				{ U"states", { U"Conditional States", JSONValueType::Array, false, g_ConditionalStateSchema } },
				{ U"secret_code", { U"Secret Code", JSONValueType::String, true, nullptr } },
				{ U"success_image", { U"Success Image Path", JSONValueType::String, true, nullptr } },
			}
		},
		{
			U"LightsOutPuzzle", {
				{ U"name", { U"Object Name", JSONValueType::String, true, nullptr } },
				{ U"hotspot", { U"Hotspot", JSONValueType::Object, true, nullptr /* g_HotspotSchema */ } },
				{ U"default_state", { U"Default State", JSONValueType::Object, true, g_ObjectStateSchema } },
				{ U"states", { U"Conditional States", JSONValueType::Array, false, g_ConditionalStateSchema } },
				{ U"initial_grid", { U"Initial Grid (2D Array of 0s/1s)", JSONValueType::Array, true, nullptr } },
			}
		},
		{
			U"Kurotto", {
				{ U"name", { U"Object Name", JSONValueType::String, true, nullptr } },
				{ U"hotspot", { U"Hotspot", JSONValueType::Object, true, nullptr /* g_HotspotSchema */ } },
				{ U"default_state", { U"Default State", JSONValueType::Object, true, g_ObjectStateSchema } },
				{ U"states", { U"Conditional States", JSONValueType::Array, false, g_ConditionalStateSchema } },
				{ U"initial_grid", { U"Initial Grid (2D Array)", JSONValueType::Array, true, nullptr } },
			}
		},
		{
			U"RotatingPuzzle", {
				{ U"name", { U"Object Name", JSONValueType::String, true, nullptr } },
				{ U"hotspot", { U"Hotspot", JSONValueType::Object, true, nullptr /* g_HotspotSchema */ } },
				{ U"default_state", { U"Default State", JSONValueType::Object, true, g_ObjectStateSchema } },
				{ U"states", { U"Conditional States", JSONValueType::Array, false, g_ConditionalStateSchema } },
				{ U"background_texture", { U"Background Texture", JSONValueType::String, false, nullptr } },
				{ U"puzzle_texture", { U"Puzzle Texture ID", JSONValueType::String, true, nullptr } },
				{ U"puzzle_width", { U"Puzzle Width (e.g., 3)", JSONValueType::Number, true, nullptr } },
				{ U"missing_pieces", { U"Missing Pieces Info", JSONValueType::Array, true, g_MissingPieceSchema } }
			}
		},
		{
			U"CardCase", {
				{ U"name", { U"Object Name", JSONValueType::String, true, nullptr } },
				{ U"hotspot", { U"Hotspot", JSONValueType::Object, true, nullptr /* g_HotspotSchema */ } },
				{ U"default_state", { U"Default State", JSONValueType::Object, true, g_ObjectStateSchema } },
				{ U"states", { U"Conditional States", JSONValueType::Array, false, g_ConditionalStateSchema } },
				{ U"texture", { U"Card Textures (Array of strings)", JSONValueType::Array, true, nullptr } },
				{ U"answers", { U"Answer Patterns", JSONValueType::Array, true, g_CardCaseAnswerSchema } }
			}
		}
};


inline Optional<Schema> GetSchema(const String& fileName)
{

	if (g_Schemas.contains(fileName))
	{
		Logger << U" -> Found schema!"; // 見つかった場合
		return g_Schemas.at(fileName);
	}

	Logger << U" -> Schema NOT found."; // 見つからなかった場合
	return none;
}

--- FILE: C:\Users\KAWAMURA Yuya\source\repos\DimensionEditor\DimensionEditor\stdafx.cpp ---


# include "stdafx.h"

--- FILE: C:\Users\KAWAMURA Yuya\source\repos\DimensionEditor\DimensionEditor\stdafx.h ---


# pragma once
//# define NO_S3D_USING
# include <Siv3D.hpp>
